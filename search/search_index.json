{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"cogeo-mosaic","text":"<p> Create mosaics of Cloud Optimized GeoTIFF based on the mosaicJSON specification. </p> <p> </p> <p>Documentation: developmentseed.org/cogeo-mosaic/</p> <p>Source Code: developmentseed/cogeo-mosaic</p> <p>Read the official announcement medium.com/devseed/cog-talk-part-2-mosaics-bbbf474e66df</p>"},{"location":"#install","title":"Install","text":"<pre><code>python -m pip install pip -U\npython -m pip install cogeo-mosaic --pre\n\n# Or from source\n\npython -m pip install git+http://github.com/developmentseed/cogeo-mosaic\n</code></pre> <p>Notes:</p> <ul> <li>Starting with version 5.0, pygeos has been replaced by shapely and thus makes <code>libgeos</code> a requirement. Shapely wheels should be available for most environment, if not, you'll need to have libgeos installed.</li> </ul>"},{"location":"#see-it-in-action","title":"See it in action","text":"<ul> <li>TiTiler: A lightweight Cloud Optimized GeoTIFF dynamic tile server (COG, STAC and MosaicJSON).</li> </ul>"},{"location":"#contribution-development","title":"Contribution &amp; Development","text":"<p>See CONTRIBUTING.md</p>"},{"location":"#license","title":"License","text":"<p>See LICENSE</p>"},{"location":"#authors","title":"Authors","text":"<p>Created by Development Seed</p> <p>See contributors for a listing of individual contributors.</p>"},{"location":"cli/","title":"CLI","text":"<pre><code>$ cogeo-mosaic --help\nUsage: cogeo-mosaic [OPTIONS] COMMAND [ARGS]...\n\n  cogeo_mosaic cli.\n\nOptions:\n  --version  Show the version and exit.\n  --help     Show this message and exit.\n\nCommands:\n  create                Create mosaic definition from list of files\n  create-from-features  Create mosaic definition from GeoJSON features or features collection\n  footprint             Create geojson from list of files\n  info                  Return info about the mosaic\n  to-geojson            Create GeoJSON from a MosaicJSON document\n  update                Update a mosaic definition from list of files\n  upload                Upload mosaic definition to backend\n</code></pre>"},{"location":"cli/#create","title":"Create","text":"<pre><code>$ cogeo-mosaic create --help\nUsage: cogeo-mosaic create [OPTIONS] [INPUT_FILES]\n\n  Create mosaic definition file.\n\nOptions:\n  -o, --output PATH       Output file name\n  --minzoom INTEGER       An integer to overwrite the minimum zoom level derived from the COGs.\n  --maxzoom INTEGER       An integer to overwrite the maximum zoom level derived from the COGs.\n  --quadkey-zoom INTEGER  An integer to overwrite the quadkey zoom level used for keys in the MosaicJSON.\n  --min-tile-cover FLOAT  Minimum % overlap\n  --tile-cover-sort       Sort files by covering %\n  --threads INTEGER       threads\n  -q, --quiet             Remove progressbar and other non-error output.\n  --help                  Show this message and exit.\n</code></pre> <p>[INPUT_FILES] must be a list of valid Cloud Optimized GeoTIFF.</p> <pre><code>$ cogeo-mosaic create list.txt -o mosaic.json\n\n# or\n\n$ cat list.txt | cogeo-mosaic create - | gzip &gt; mosaic.json.gz\n\n# or use backends like AWS S3 or DynamoDB\n\n$ cogeo-mosaic create list.txt -o s3://my-bucket/my-key.json.gz\n</code></pre>"},{"location":"cli/#example-create-a-mosaic-from-oam","title":"Example: create a mosaic from OAM","text":"<pre><code># Create Mosaic\n$ curl https://api.openaerialmap.org/user/5d6a0d1a2103c90007707fa0 | jq -r '.results.images[] | .uuid' | cogeo-mosaic create - | gzip &gt;  5d6a0d1a2103c90007707fa0.json.gz\n\n# Create Footprint (optional)\n$ curl https://api.openaerialmap.org/user/5d6a0d1a2103c90007707fa0 | jq -r '.results.images[] | .uuid' | cogeo-mosaic footprint | gist -p -f test.geojson\n</code></pre>"},{"location":"cli/#create-mosaic-definition-from-a-geojson-features-collection-eg-stac","title":"Create Mosaic definition from a GeoJSON features collection (e.g STAC)","text":"<p>This module is first design to create mosaicJSON from a set of COG urls but starting in version <code>3.0.0</code> we have added a CLI to be able to create mosaicJSON from GeoJSON features. <pre><code>$ cogeo-mosaic create-from-features --help\nUsage: cogeo-mosaic create-from-features [OPTIONS] FEATURES...\n\n  Create mosaic definition file.\n\nOptions:\n  -o, --output PATH       Output file name\n  --minzoom INTEGER       Mosaic minimum zoom level.  [required]\n  --maxzoom INTEGER       Mosaic maximum zoom level.  [required]\n  --property TEXT         Define accessor property  [required]\n  --quadkey-zoom INTEGER  An integer to overwrite the quadkey zoom level used for keys in the MosaicJSON.\n  --min-tile-cover FLOAT  Minimum % overlap\n  --tile-cover-sort       Sort files by covering %\n  -q, --quiet             Remove progressbar and other non-error output.\n  --help                  Show this message and exit.\n</code></pre></p>"},{"location":"cli/#use-it-with-stac","title":"Use it with STAC","text":"<pre><code>$ curl https://earth-search.aws.element84.com/collections/landsat-8-l1/items | \\\n    cogeo-mosaic create-from-features --minzoom 7 --maxzoom 12 --property \"landsat:scene_id\" --quiet | \\\n    jq\n\n{\n  \"mosaicjson\": \"0.0.2\",\n  \"version\": \"1.0.0\",\n  \"minzoom\": 7,\n  \"maxzoom\": 12,\n  \"quadkey_zoom\": 7,\n  \"bounds\": [16.142300225571994, -28.513088675819393, 67.21380296165974, 81.2067478836583],\n  \"center\": [41.67805159361586, 26.346829603919453, 7],\n  \"tiles\": {\n    \"1012123\": [\n      \"LC81930022020114LGN00\"\n    ],\n    ...\n  }\n}\n</code></pre>"},{"location":"contributing/","title":"Development - Contributing","text":"<p>Issues and pull requests are more than welcome.</p> <p>We recommand using <code>uv</code> as project manager for development.</p> <p>See docs.astral.sh/uv/getting-started/installation/ for installation </p>"},{"location":"contributing/#dev-install","title":"dev install","text":"<pre><code>git clone http://github.com/developmentseed/cogeo-mosaic.git\ncd cogeo-mosaic\n\nuv sync --all-extras\n</code></pre> <p>You can then run the tests with the following command:</p> <pre><code>uv run pytest  --cov cogeo_mosaic --cov-report term-missing\n</code></pre>"},{"location":"contributing/#pre-commit","title":"pre-commit","text":"<p>This repo is set to use <code>pre-commit</code> to run isort, flake8, pydocstring, black (\"uncompromising Python code formatter\") and mypy when committing new code.</p> <pre><code>uv run pre-commit install\n\ngit add .\n\ngit commit -m'my change'\nisort....................................................................Passed\nblack....................................................................Passed\nFlake8...................................................................Passed\nVerifying PEP257 Compliance..............................................Passed\nmypy.....................................................................Passed\n\ngit push origin\n</code></pre>"},{"location":"contributing/#docs","title":"Docs","text":"<pre><code>git clone https://github.com/developmentseed/cogeo-mosaic.git\ncd cogeo-mosaic\n</code></pre> <p>Hot-reloading docs:</p> <pre><code>uv run --group docs mkdocs serve -f docs/mkdocs.yml\n</code></pre> <p>To manually deploy docs (note you should never need to do this because Github Actions deploys automatically for new commits.):</p> <pre><code>uv run --group docs mkdocs gh-deploy -f docs/mkdocs.yml\n</code></pre>"},{"location":"intro/","title":"Intro","text":"<p>cogeo-mosaic is set of CLI and API to create, store and read MosaicJSON documents.</p>"},{"location":"intro/#mosaicjson-model","title":"MosaicJSON Model","text":"<p>cogeo-mosaic uses Pydantic model to store and validate mosaicJSON documents. <pre><code>class MosaicJSON(BaseModel):\n    mosaicjson: str\n    name: Optional[str]\n    description: Optional[str]\n    version: str = \"1.0.0\"\n    attribution: Optional[str]\n    minzoom: int = Field(0, ge=0, le=30)\n    maxzoom: int = Field(30, ge=0, le=30)\n    quadkey_zoom: Optional[int]\n    bounds: List[float] = Field([-180, -90, 180, 90])\n    center: Optional[Tuple[float, float, int]]\n    tiles: Dict[str, List[str]]\n    tilematrixset: Optional[morecantile.TileMatrixSet]\n    asset_type: Optional[str]\n    asset_prefix: Optional[str]\n    data_type: Optional[str]\n    colormap: Optional[Dict[int, Tuple[int, int, int, int]]]\n    layers: Optional[Dict]\n</code></pre></p> <p>The model is based on the mosaicjson specification: developmentseed/mosaicjson-spec</p> <p>Pydantic models are python classes which are extansible. Here is an example of how we can use the MosaicJSON model to create a mosaic from a list of COG urls:</p> <pre><code>from cogeo_mosaic.mosaic import MosaicJSON\n\n# list of COG\ndataset = [\"1.tif\", \"2.tif\"]\nmosaic_definition = MosaicJSON.from_urls(dataset)\n\nprint(mosaic_definition.tiles)\n&gt; {\"tile\": {\"00001\": [\"cog1.tif\", \"2.tif\"]}}\n</code></pre> <p>Lear more on MosaicJSON class API/mosaic.</p>"},{"location":"intro/#backends","title":"Backends","text":"<p>MosaicJSON <code>backends</code> are python classes, based on rio-tiler BaseBackend, which are used to interact with MosaicJSON documents, stored on AWS DynamoDB, AWS S3, locally, or on the web (http://).</p> <p>Because each Backends extend rio-tiler BaseBackend they share the same minimal methods/properties</p> <pre><code>from cogeo_mosaic.backends import MosaicJSONBackend\nprint(MosaicJSONBackend.__bases__)\n&gt;&gt; (&lt;class 'rio_tiler.mosaic.backend.BaseBackend'&gt;,)\n</code></pre> <pre><code>from cogeo_mosaic.backends.s3 import S3Backend\n\n# Read\nwith S3Backend(\"s3://mybucket/amosaic.json\") as mosaic:\n    mosaic.input                                   # attribute - MosaicJSON path\n    mosaic.mosaic_def                              # attribute - MosaicJSON document, wrapped in a Pydantic Model\n    mosaic.reader                                  # attribute - BaseReader, MultiBaseReader, MultiBandReader to use to fetch tile data\n    mosaic.reader_options                          # attribute - Options for forward to `reader`\n    mosaic.tms                                     # attribute - TileMatrixSet (default to WebMercatorQuad)\n    mosaic.minzoom                                 # attribute - Mosaic (default to tms or mosaic minzoom)\n    mosaic.maxzoom                                 # attribute - Mosaic (default to tms or mosaic maxzoom)\n\n    mosaic.crs                                     # property - CRS (from mosaic's TMS geographic CRS)\n    mosaic.bounds                                  # property - Mosaic bounds in `mosaic.crs`\n\n    mosaic.mosaicid                                # property - Return sha224 id from the mosaicjson doc\n    mosaic.quadkey_zoom                            # property - Return Quadkey zoom of the mosaic\n\n    mosaic.write()                                 # method - Write the mosaicjson to the given location\n    mosaic.update([features])                      # method - Update the mosaicjson data with a list of features\n\n    mosaic.info(quadkeys=True/False)               # method -  spatial_info, list of quadkeys and mosaic name\n\n    mosaic.get_geographic_bounds(crs: CRS)         # method - Return mosaic bounds in a geographic CRS\n\n    mosaic.assets_for_tile(x, y, z)                # method - Find assets for a specific mercator tile\n    mosaic.assets_for_point(lng, lat)              # method - Find assets for a specific point\n    mosaic.assets_for_bbox(xmin, ymin, xmax, ymax) # method - Find assets for a specific bbox\n\n    mosaic.tile(1,2,3)                             # method - Create mosaic tile\n    mosaic.point(lng, lat)                         # method - Read point value from multiple assets\n    mosaic.part(bbox)                              # method - Create image from part of multiple assets\n    mosaic.feature(feature)                        # method - Create image from GeoJSON feature of multiple assets\n</code></pre> <p>Important</p> <p><code>statistics()</code>, <code>preview()</code> methods are not implemented in BaseBackend</p>"},{"location":"intro/#open-mosaic-and-get-assets-list-for-a-tile","title":"Open Mosaic and Get assets list for a tile","text":"<pre><code>from cogeo_mosaic.backends import MosaicBackend\n\nwith MosaicBackend(\"s3://mybucket/amosaic.json\") as mosaic:\n    assets: List[str] = mosaic.assets_for_tile(1, 2, 3) # get assets for morecantile.Tile(1, 2, 3)\n</code></pre> <p>Important</p> <p><code>MosaicBackend</code> is a function which returns the correct <code>backend</code> by checking the path/url schema.</p> <p>see MosaicBackend</p>"},{"location":"intro/#open-mosaic-and-get-tile-data-mosaic-tile","title":"Open Mosaic and get Tile Data (mosaic tile)","text":"<pre><code>from cogeo_mosaic.backends import MosaicBackend\n\nwith MosaicBackend(\"s3://mybucket/amosaic.json\") as mosaic:\n    img: ImageData, assets_used: List[str] = mosaic.tile(1, 2, 3)\n</code></pre>"},{"location":"intro/#write-mosaic","title":"Write Mosaic","text":"<pre><code>from cogeo_mosaic.mosaic import MosaicJSON\nfrom cogeo_mosaic.backends import MosaicBackend\n\n# Create a MosaicJSON\nmosaicdata = MosaicJSON.from_urls([\"1.tif\", \"2.tif\"])\n\nwith MosaicBackend(\"s3://mybucket/amosaic.json\", mosaic_def=mosaicdata) as mosaic:\n    mosaic.write() # trigger upload to S3\n</code></pre>"},{"location":"intro/#update-a-mosaic","title":"Update a Mosaic","text":"<pre><code>from cogeo_mosaic.utils import get_footprints\nfrom cogeo_mosaic.backends import MosaicBackend\n\nwith MosaicBackend(\"s3://mybucket/amosaic.json\") as mosaic:\n    features = get_footprints([\"3.tif\"]) # Get footprint\n    mosaic.update(features) # Update mosaicJSON and upload to S3\n</code></pre>"},{"location":"intro/#in-memory-mosaic","title":"In Memory Mosaic","text":"<pre><code>from cogeo_mosaic.mosaic import MosaicJSON\nfrom cogeo_mosaic.backends import MosaicBackend\n\nfrom cogeo_mosaic.backends.memory import MemoryBackend\n\nmosaic_definition = MosaicJSON.from_urls([\"1.tif\", \"2.tif\"])\n\n# If set to None or :memory:, MosaicBackend will use the MemoryBackend\nwith MosaicBackend(\":memory:\", mosaic_def=mosaicdata) as mosaic:\n    assert isinstance(mosaic, MemoryBackend)\n    img, assets_used = mosaic.tile(1, 2, 3)\n\nwith MosaicBackend(None, mosaic_def=mosaicdata) as mosaic:\n    assert isinstance(mosaic, MemoryBackend)\n    img, assets_used = mosaic.tile(1, 2, 3)\n\nwith MemoryBackend(mosaic_def=mosaicdata) as mosaic:\n    img, assets_used = mosaic.tile(1, 2, 3)\n</code></pre>"},{"location":"intro/#tilematrixset-attribute","title":"TileMatrixSet attribute","text":"<pre><code>from cogeo_mosaic.backends import MosaicBackend\nimport morecantile\n\n# Mosaic in WebMercatorQuad (default), output tile in WGS84\nWGS1984Quad = morecantile.tms.get(\"WGS1984Quad\")\n\nwith MosaicBackend(\"s3://mybucket/amosaic.json\", tms=WGS1984Quad) as mosaic:\n    img: ImageData, assets_used: List[str] = mosaic.tile(1, 2, 3)\n\n    # The mosaic might use a specific TMS (WebMercatorQuad by default)\n    assert mosaic.mosaic_def.tilematrixset.rasterio_crs == \"epsg:3857\"\n\n    # When passing `tms=`, the output tile image will have the CRS from the input TMS\n    assert img.crs == \"epsg:4326\"\n</code></pre>"},{"location":"intro/#image-order","title":"Image Order","text":"<p>By default the order of the dataset, either passed via the CLI or in the API, defines the order of the quadkey's assets.</p> <pre><code>from cogeo_mosaic.mosaic import MosaicJSON\n\n# list of COG\ndataset = [\"1.tif\", \"2.tif\"]\nmosaic_definition = MosaicJSON.from_urls(dataset)\n\nprint(mosaic_definition.tiles)\n&gt; {\"tile\": {\"0\": [\"1.tif\", \"2.tif\"]}}\n</code></pre>"},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#unreleased","title":"Unreleased","text":""},{"location":"release-notes/#902-2025-12-15","title":"9.0.2 (2025-12-15)","text":"<ul> <li>add support for python 3.14</li> </ul>"},{"location":"release-notes/#901-2025-11-25","title":"9.0.1 (2025-11-25)","text":"<ul> <li>update morecantile requirements to <code>&gt;=7.0</code></li> </ul>"},{"location":"release-notes/#900-2025-11-21","title":"9.0.0 (2025-11-21)","text":"<ul> <li>update rio-tiler requirement to <code>&gt;=8.0,&lt;9.0</code></li> <li>rename <code>cogeo_mosaic.backends.base.BaseBackend</code> to <code>cogeo_mosaic.backends.base.MosaicJSONBackend</code> breaking change</li> <li><code>cogeo_mosaic.backends.base.MosaicJSONBackend</code> subclass <code>rio_tiler.mosaic.backend.BaseBackend</code></li> <li>remove <code>.center</code> property from <code>MosaicJSONBackend</code> breaking change</li> <li> <p><code>reverse</code> option should be passed via <code>search_options</code> breaking change</p> <pre><code># before\nwith MemoryBackend(mosaic_def=...) as mosaic:\n    ptsR = mosaic.point(-73, 45, reverse=True)\n\n# now\nwith MemoryBackend(mosaic_def=...) as mosaic:\n    ptsR = mosaic.point(-73, 45, search_options={\"reverse\": True})\n</code></pre> </li> </ul>"},{"location":"release-notes/#820-2025-05-06","title":"8.2.0 (2025-05-06)","text":"<ul> <li>allow <code>kwargs</code> to be forwarded to backend's <code>get_assets</code> method from <code>assets_for_tile</code>, <code>assets_for_point</code> and <code>assets_for_bbox</code> methods</li> </ul>"},{"location":"release-notes/#810-2025-02-13","title":"8.1.0 (2025-02-13)","text":"<ul> <li>add <code>lock=Lock()</code> to cachetools <code>cached</code> instance to avoid thread corruption</li> <li>remove python 3.8 support</li> <li>add python 3.13 support</li> </ul>"},{"location":"release-notes/#800-2024-10-21","title":"8.0.0 (2024-10-21)","text":"<ul> <li> <p>remove deprecated methods</p> </li> <li> <p>update morecantile requirement to <code>&gt;=5.0,&lt;7.0</code></p> </li> <li> <p>update rio-tiler requirement to <code>&gt;=7.0,&lt;8.0</code></p> </li> <li> <p>update <code>Info</code> model</p> <pre><code># before\nclass Info(BaseModel):\n    bounds: BBox = Field(default=(-180, -90, 180, 90))\n    center: Optional[Tuple[float, float, int]] = None\n    minzoom: int = Field(0, ge=0, le=30)\n    maxzoom: int = Field(30, ge=0, le=30)\n    name: Optional[str] = None\n    quadkeys: List[str] = []\n    tilematrixset: Optional[str] = None\n\n# now\nclass Info(BaseModel):\n    bounds: BBox = Field(default=(-180, -90, 180, 90))\n    crs: str\n    center: Optional[Tuple[float, float, int]] = None\n    name: Optional[str] = None\n    quadkeys: List[str] = []\n    mosaic_tilematrixset: Optional[str] = None\n    mosaic_minzoom: int = Field(0, ge=0, le=30)\n    mosaic_maxzoom: int = Field(30, ge=0, le=30)\n</code></pre> </li> </ul>"},{"location":"release-notes/#720-2024-10-04","title":"7.2.0 (2024-10-04)","text":"<ul> <li>update BaseBackend to use a default coord_crs from the tms (author @AndrewAnnex, developmentseed/cogeo-mosaic!234)</li> <li>add python 3.12 support</li> <li>Add tms parameter to cli for MosaicJSON (co-author @AndrewAnnex, developmentseed/cogeo-mosaic!233)</li> </ul>"},{"location":"release-notes/#710-2023-12-06","title":"7.1.0 (2023-12-06)","text":"<ul> <li>Automatically remove/add <code>asset_prefix</code> in Mosaic Backends</li> </ul>"},{"location":"release-notes/#701-2023-10-17","title":"7.0.1 (2023-10-17)","text":"<ul> <li>add <code>py.typed</code> file (peps.python.org/pep-0561)</li> </ul>"},{"location":"release-notes/#700-2023-07-26","title":"7.0.0 (2023-07-26)","text":"<ul> <li>update <code>morecantile</code> requirement to <code>&gt;=5.0,&lt;6.0</code></li> <li>update <code>rio-tiler</code> requirement to <code>&gt;=6.0,&lt;7.0</code></li> <li>update <code>pydantic</code> requirement to <code>~=2.0</code></li> </ul>"},{"location":"release-notes/#620-2023-07-11","title":"6.2.0 (2023-07-11)","text":"<ul> <li>add <code>coord_crs</code> to <code>MosaicBackend.point()</code> method</li> </ul>"},{"location":"release-notes/#610-2023-07-11","title":"6.1.0 (2023-07-11)","text":"<ul> <li>add <code>tilematrixset</code> in <code>MosaicBackend.info()</code> response</li> </ul>"},{"location":"release-notes/#601-2023-07-11","title":"6.0.1 (2023-07-11)","text":"<ul> <li>fix <code>HttpBackend</code> post_init method</li> </ul>"},{"location":"release-notes/#600-2023-07-10","title":"6.0.0 (2023-07-10)","text":"<ul> <li> <p>update <code>morecantile&gt;=4.1,&lt;5.0</code> and <code>rio-tiler&gt;=5.0,&lt;6.0</code> requirements</p> </li> <li> <p>replace <code>supermercado</code> with <code>supermorecado</code> to burn geometries as tiles for different TMS</p> </li> <li> <p>update MosaicJSON models to <code>0.0.3</code> specification (adds <code>tilematrixset</code>, <code>asset_type</code>, <code>asset_prefix</code>, <code>data_type</code>, <code>colormap</code> and <code>layers</code> attributes)</p> </li> <li> <p>allow Mosaic creation using other TileMatrixSet (default is still <code>WebMercatorQuad</code>)</p> </li> <li> <p>add <code>tms</code> support to MosaicBackend to read tile in other TMS than the mosaic TileMatrixSet</p> <pre><code># Before\n# Mosaic and output Tile in WebMercatorQuad\nwith MosaicBackend(\"mosaic.json\") as mosaic:\n    img, _ = mosaic.tile(0, 0, 0)\n\n# Now\n# Mosaic in WebMercatorQuad (default), output tile in WGS84\nWGS1984Quad = morecantile.tms.get(\"WGS1984Quad\")\nwith MosaicBackend(\"mosaic.json\", tms=WGS1984Quad) as mosaic:\n    img, _ = mosaic.tile(0, 0, 0)\n</code></pre> </li> </ul>"},{"location":"release-notes/#511-2023-02-06","title":"5.1.1 (2023-02-06)","text":"<ul> <li>Clip dataset bounds with of TMS bbox (author @lseelenbinder, developmentseed/cogeo-mosaic!200)</li> </ul>"},{"location":"release-notes/#510-2023-01-20","title":"5.1.0 (2023-01-20)","text":"<ul> <li>use <code>az://</code> prefix for private Azure Blob Storage Backend.</li> </ul>"},{"location":"release-notes/#500-2022-11-21","title":"5.0.0 (2022-11-21)","text":"<ul> <li>switch from pygeos to shapely&gt;=2.0</li> </ul>"},{"location":"release-notes/#422-2022-11-19","title":"4.2.2 (2022-11-19)","text":"<ul> <li>remove useless file in package</li> </ul>"},{"location":"release-notes/#421-2022-11-15","title":"4.2.1 (2022-11-15)","text":"<ul> <li>add python 3.11 support</li> </ul>"},{"location":"release-notes/#420-2022-10-24","title":"4.2.0 (2022-10-24)","text":"<ul> <li>remove python 3.7 support</li> <li>add python 3.10 support</li> <li>switch to hatch build-system</li> <li>update rio-tiler dependency to &gt;=4.0.0a0</li> </ul>"},{"location":"release-notes/#411-2022-10-21","title":"4.1.1 (2022-10-21)","text":"<ul> <li>Add Azure Blob Storage backend (author @christoe, developmentseed/cogeo-mosaic!191)</li> </ul>"},{"location":"release-notes/#410-2022-02-22","title":"4.1.0 (2022-02-22)","text":"<ul> <li>remove <code>mercantile</code> and switch to morecantile&gt;=3.1</li> </ul>"},{"location":"release-notes/#400-2021-11-30","title":"4.0.0 (2021-11-30)","text":"<ul> <li>no change since <code>4.0.0a2</code></li> </ul>"},{"location":"release-notes/#400a2-2021-11-22","title":"4.0.0a2 (2021-11-22)","text":"<ul> <li>update rio-tiler requirement (<code>&gt;=3.0.0a6</code>) and update backend reader type information</li> </ul>"},{"location":"release-notes/#400a1-2021-11-18","title":"4.0.0a1 (2021-11-18)","text":"<ul> <li>update rio-tiler requirement (<code>&gt;=3.0.0a5</code>)</li> <li>fix <code>MosaicBackend</code> to match Backend input names.</li> </ul>"},{"location":"release-notes/#400a0-2021-10-20","title":"4.0.0a0 (2021-10-20)","text":"<ul> <li>update morecantile requirement to &gt;= 3.0</li> <li>update rio-tiler requirement to &gt;= 3.0 and update Backend's properties</li> <li>switch from <code>requests</code> to <code>httpx</code></li> <li>add <code>BaseBackend.assets_for_bbox()</code> method (developmentseed/cogeo-mosaic!184)</li> </ul> <p>breaking changes</p> <ul> <li>remove <code>BaseBackend.metadata()</code> method (can be replaced by <code>BaseBackend.mosaic_def.dict(exclude={\"tiles\"})</code>)</li> <li>remove <code>cogeo_mosaic.models.Metadata</code> model</li> <li>remove python 3.6 support</li> <li><code>BaseBackend.path</code> -&gt; <code>BaseBackend.input</code> attribute (<code>input</code> was added in rio-tiler BaseReader)</li> </ul>"},{"location":"release-notes/#302-2021-07-08","title":"3.0.2 (2021-07-08)","text":"<ul> <li>Add Google Cloud Storage (<code>gs://...</code>) mosaic backend (author @AndreaGiardini, developmentseed/cogeo-mosaic!179)</li> </ul>"},{"location":"release-notes/#301-2021-06-22","title":"3.0.1 (2021-06-22)","text":"<ul> <li>Make sure to pass an openned file to click.Progressbar (developmentseed/cogeo-mosaic!178)</li> </ul>"},{"location":"release-notes/#300-2021-05-19","title":"3.0.0 (2021-05-19)","text":"<ul> <li>update rio-tiler version dependencies</li> <li>update pygeos dependency to &gt;=0.10 which fix developmentseed/cogeo-mosaic#81</li> </ul>"},{"location":"release-notes/#300rc2-2021-02-25","title":"3.0.0rc2 (2021-02-25)","text":"<p>breaking</p> <ul> <li><code>gzip</code> is now only applied if the path endswith <code>.gz</code></li> <li>remove <code>backend_options</code> attribute in base backends. This attribute was used to pass optional <code>gzip</code> option and/or STAC related options</li> <li>STAC backends has additional attributes (<code>stac_api_options</code> and <code>mosaic_options</code>)</li> </ul>"},{"location":"release-notes/#300rc1-2021-02-11","title":"3.0.0rc1 (2021-02-11)","text":"<ul> <li>add <code>SQLite</code> backend (developmentseed/cogeo-mosaic!148)</li> <li>fix cached responsed after updating a mosaic (github.com/developmentseed/cogeo-mosaic/pull/148/files#r557020660)</li> <li>update mosaicJSON.bounds type definition to match rio-tiler BaseReader definition (developmentseed/cogeo-mosaic#158)</li> <li>add default bounds/minzoom/maxzoom values matching the mosaicjson default in the backends (developmentseed/cogeo-mosaic!162)</li> <li>raise an error when trying to pass <code>mosaic_def</code> in read-only backend (developmentseed/cogeo-mosaic!162)</li> <li>add <code>MemoryBackend</code> (developmentseed/cogeo-mosaic!163)</li> </ul> <p>breaking</p> <ul> <li>Updated the backends <code>.point()</code> methods to return a list in form of <code>[(asset1, values)]</code> (developmentseed/cogeo-mosaic!168)</li> </ul>"},{"location":"release-notes/#300b1-2020-12-18","title":"3.0.0b1 (2020-12-18)","text":"<ul> <li>remove <code>overview</code> command (github.com/developmentseed/cogeo-mosaic/issues/71#issuecomment-748265645)</li> <li>remove <code>rio-cogeo</code> dependencies</li> <li>update rio-tiler version (<code>2.0.0rc4</code>)</li> </ul>"},{"location":"release-notes/#300a19-2020-12-14","title":"3.0.0a19 (2020-12-14)","text":"<ul> <li>Update to remove all calls to <code>rio_tiler.mercator</code> functions.</li> </ul>"},{"location":"release-notes/#300a18-2020-11-24","title":"3.0.0a18 (2020-11-24)","text":"<ul> <li>update Backend base class for rio-tiler 2.0.0rc3 (add <code>.feature()</code> method)</li> </ul>"},{"location":"release-notes/#300a17-2020-11-09","title":"3.0.0a17 (2020-11-09)","text":"<ul> <li>update for rio-tiler 2.0rc and add backend output models</li> </ul>"},{"location":"release-notes/#300a16-2020-10-26","title":"3.0.0a16 (2020-10-26)","text":"<ul> <li>raise <code>MosaicNotFoundError</code> when mosaic doesn't exists in the DynamoDB table.</li> </ul>"},{"location":"release-notes/#300a15-2020-10-22","title":"3.0.0a15 (2020-10-22)","text":"<ul> <li>fix typo in DynamoDB backend (developmentseed/cogeo-mosaic!134)</li> <li>rename <code>cogeo_mosaic/backends/http.py</code> -&gt; <code>cogeo_mosaic/backends/web.py</code> to avoid conflicts (author @kylebarron, developmentseed/cogeo-mosaic!133)</li> </ul>"},{"location":"release-notes/#300a14-2020-10-22","title":"3.0.0a14 (2020-10-22)","text":"<ul> <li>add logger (<code>cogeo_mosaic.logger.logger</code>)</li> <li>Update STACBackend to better handler paggination (ref: developmentseed/cogeo-mosaic!125)</li> <li>with change from #125, <code>stac_next_link_key</code> has be specified if you know the STAC API is using the latest specs:</li> </ul> <pre><code>with MosaicBackend(\n    f\"stac+{stac_endpoint}\",\n    query.copy(),\n    11,\n    14,\n    backend_options={\n        \"accessor\": lambda feature: feature[\"id\"],\n        \"stac_next_link_key\": \"next\",\n    }\n) as mosaic:\n</code></pre> <ul> <li>add <code>to-geojson</code> CLI to create a GeoJSON from a mosaicJSON document (#128)</li> <li>refactor internal cache (developmentseed/cogeo-mosaic!131)</li> <li>add progressbar for iterating over quadkeys when creating a mosaic (author @kylebarron, developmentseed/cogeo-mosaic!130)</li> </ul>"},{"location":"release-notes/#breaking-changes","title":"Breaking changes","text":"<ul> <li> <p>refactored DynamoDB backend to store multiple mosaics in one table (developmentseed/cogeo-mosaic!127)</p> <ul> <li>new path schema <code>dynamodb://{REGION}?/{TABLE}:{MOSAIC}</code></li> </ul> </li> <li> <p>renamed exception <code>MosaicExists</code> to <code>MosaicExistsError</code></p> </li> <li>renamed option <code>fetch_quadkeys</code> to <code>quadkeys</code> in DynamoDBBackend.info() method</li> <li>add <code>quadkeys</code> option in <code>Backends.info()</code> to return (or not) the list of quadkeys (developmentseed/cogeo-mosaic!129)</li> <li>moves <code>get_assets</code> to the base Backend (developmentseed/cogeo-mosaic!131)</li> <li>remove multi_level mosaic support (developmentseed/cogeo-mosaic#122)</li> </ul>"},{"location":"release-notes/#300a13-2020-10-13","title":"3.0.0a13 (2020-10-13)","text":"<ul> <li>add TMS in BaseBackend to align with rio-tiler BaseBackend.</li> </ul>"},{"location":"release-notes/#300a12-2020-10-07","title":"3.0.0a12 (2020-10-07)","text":"<ul> <li>remove pkg_resources (pypa/setuptools#510)</li> <li>raise error when <code>minimum_tile_cover</code> is &gt; 1 (developmentseed/cogeo-mosaic#117)</li> <li>fix wrong indices sorting in default_filter (developmentseed/cogeo-mosaic#118)</li> </ul> <p>Note: We changed the versioning scheme to {major}.{minor}.{path}{pre}{prenum}</p>"},{"location":"release-notes/#30a11-2020-09-21","title":"3.0a11 (2020-09-21)","text":"<ul> <li>Raise Exception when trying to overwrite a mosaic (#112)</li> <li>Add <code>reverse</code> option in <code>.tile</code> and <code>.point</code> to get values from assets in reversed order.</li> </ul>"},{"location":"release-notes/#30a10-2020-08-24","title":"3.0a10 (2020-08-24)","text":"<ul> <li>Allow PointOutsideBounds exception for <code>point</code> method (#108)</li> </ul>"},{"location":"release-notes/#30a9-2020-08-24","title":"3.0a9 (2020-08-24)","text":"<ul> <li>BaseBackend.center returns value from the mosaic definition (#105)</li> </ul>"},{"location":"release-notes/#30a8-2020-08-21","title":"3.0a8 (2020-08-21)","text":"<ul> <li>BaseBackend is now a subclass of rio-tiler.io.base.BaseReader (add minzoom, maxzoom, bounds properties and info method)</li> <li>use <code>attr</code> to define backend classes</li> </ul>"},{"location":"release-notes/#breaking-changes_1","title":"Breaking changes","text":"<ul> <li><code>backend_options</code> is now used to pass options (*kwargs) to the <code>_read</code> method</li> </ul>"},{"location":"release-notes/#30a7-2020-07-31","title":"3.0a7 (2020-07-31)","text":"<ul> <li>update to rio-tiler 2.0b5</li> </ul>"},{"location":"release-notes/#breaking-changes_2","title":"Breaking changes","text":"<ul> <li>'value' -&gt; 'values' in MosaicBackend.point output (#98)</li> </ul>"},{"location":"release-notes/#30a6-2020-07-31","title":"3.0a6 (2020-07-31)","text":"<ul> <li>Use environement variable to set/disable cache (#93, autho @geospatial-jeff)</li> <li>Allow Threads configuration for overview command (author @kylebarron)</li> <li>add --in-memory/--no-in-memory to control temporary files creation for <code>overview</code> function.</li> <li>allow pixel_selection method options for <code>overview</code> function.</li> <li>update to rio-tiler 2.0b4</li> <li>use new COGReader and STACReader to add .tile and .point methods directly in the backends</li> </ul>"},{"location":"release-notes/#breaking-changes_3","title":"Breaking changes","text":"<ul> <li>backend.tile -&gt; backend.assets_for_tile</li> <li>backend.point -&gt; backend.assets_for_point</li> </ul>"},{"location":"release-notes/#30a5-2020-06-29","title":"3.0a5 (2020-06-29)","text":"<ul> <li>remove FTP from supported backend (#87, author @geospatial-jeff)</li> <li>add backend CRUD exceptions (#86, author @geospatial-jeff)</li> </ul>"},{"location":"release-notes/#30a4-2020-06-25","title":"3.0a4 (2020-06-25)","text":"<ul> <li>add STACBackend (#82)</li> <li>fix backends caching and switch to TTL cache (#83)</li> </ul>"},{"location":"release-notes/#30a3-2020-05-01","title":"3.0a3 (2020-05-01)","text":"<ul> <li>add Upload CLI (#74, author @kylebarron)</li> <li>fix boto3 dynamodb exception (#75)</li> </ul>"},{"location":"release-notes/#30a2-2020-05-01","title":"3.0a2 (2020-05-01)","text":"<ul> <li>Better mosaicJSON model testing and default center from bounds (#73, author @geospatial-jeff)</li> </ul>"},{"location":"release-notes/#30a1-2020-05-01","title":"3.0a1 (2020-05-01)","text":"<p>This is a major version, meaning a lot of refactoring was done and may lead to breaking changes.</p> <ul> <li>add quadkey_zoom option in CLI (#41, author @kylebarron)</li> <li>use R-tree from pygeos for testing intersections (#43, author @kylebarron)</li> </ul>"},{"location":"release-notes/#breaking-changes_4","title":"Breaking changes","text":"<ul> <li>added BackendStorage for dynamodb, s3, file and http (with @kylebarron)</li> <li>added MosaicJSON pydantic model for internal mosaicjson representation (with @kylebarron and @geospatial-jeff)</li> </ul>"},{"location":"release-notes/#201-2020-01-28","title":"2.0.1 (2020-01-28)","text":"<ul> <li>Bug fix, use pygeos from pypi instead of git repo</li> </ul>"},{"location":"release-notes/#200-2020-01-28-major-refactor","title":"2.0.0 (2020-01-28) - Major refactor","text":"<ul> <li>remove stack related code (lambda handler, serverless)</li> <li>switch to pygeos (#24)</li> <li>bug fixes</li> <li>add <code>last</code> pixel_method</li> </ul>"},{"location":"release-notes/#100-2019-12-13","title":"1.0.0 (2019-12-13)","text":"<ul> <li>add tif output</li> <li>fix overview creation</li> <li>add other Web templates</li> </ul>"},{"location":"release-notes/#030-2019-11-07","title":"0.3.0 (2019-11-07)","text":"<ul> <li>use aws lambda layer</li> <li>add <code>update_mosaic</code> utility function</li> <li>add <code>/tiles/point</code> endpoint to get points values from a mosaic</li> <li>add logs for mosaic creation</li> <li>add custom pixel methods</li> <li>add custom color maps</li> </ul>"},{"location":"release-notes/#breaking-changes_5","title":"Breaking changes","text":"<ul> <li>rename <code>/mosaic/info/&lt;mosaicid&gt;</code> to <code>/mosaic/&lt;mosaicid&gt;/info</code></li> </ul>"},{"location":"release-notes/#020-2019-09-30","title":"0.2.0 (2019-09-30)","text":"<ul> <li>update for lambda-proxy~=5.0 (#15)</li> <li>add <code>minimum_tile_cover</code> option for mosaic creation (#16)</li> <li>add <code>tile_cover_sort</code> option (#16)</li> <li>add verbosity for cli</li> </ul>"},{"location":"release-notes/#010-2019-09-05","title":"0.1.0 (2019-09-05)","text":"<ul> <li>add /create.html endpoint (#14)</li> <li>update to remotepixel/amazonlinux docker image</li> </ul>"},{"location":"v3_migration/","title":"cogeo-mosaic 2.0 to 3.0 migration guide","text":""},{"location":"v3_migration/#mosaicjson-pydantic-model","title":"MosaicJSON pydantic model","text":"<p>We now use pydantic to define the MosaicJSON document. Pydantic</p> <p>From Pydantic docs:</p> <p>Define how data should be in pure, canonical python; validate it with pydantic.</p> <p>Pydantic model enforce the mosaicjson specification for the whole project by validating each items.</p> <pre><code>from pydantic import BaseModel\n\nclass MosaicJSON(BaseModel):\n    \"\"\"\n    MosaicJSON model.\n\n    Based on https://github.com/developmentseed/mosaicjson-spec\n\n    \"\"\"\n\n    mosaicjson: str\n    name: Optional[str]\n    description: Optional[str]\n    version: str = \"1.0.0\"\n    attribution: Optional[str]\n    minzoom: int = Field(0, ge=0, le=30)\n    maxzoom: int = Field(30, ge=0, le=30)\n    quadkey_zoom: Optional[int]\n    bounds: List[float] = Field([-180, -90, 180, 90])\n    center: Optional[Tuple[float, float, int]]\n    tiles: Dict[str, List[str]]\n</code></pre>"},{"location":"v3_migration/#validation","title":"Validation","text":"<pre><code>mosaic_definition = dict(\n    mosaicjson=\"0.0.2\",\n    minzoom=1,\n    maxzoom=2,\n    quadkey_zoom=1,\n    bounds=[-180, -90, 180, 90],\n    center=(0, 0, 1),\n    tiles={},\n)\n\nm = MosaicJSON(**mosaic_definition)\n&gt; MosaicJSON(mosaicjson='0.0.2', name=None, description=None, version='1.0.0', attribution=None, minzoom=1, maxzoom=2, quadkey_zoom=1, bounds=[-180.0, -90.0, 180.0, 90.0], center=(0.0, 0.0, 1), tiles={})\n</code></pre> <pre><code># convert the mode to a dict\nm.dict(exclude_none=True)\n&gt; {'mosaicjson': '0.0.2',\n 'version': '1.0.0',\n 'minzoom': 1,\n 'maxzoom': 2,\n 'quadkey_zoom': 1,\n 'bounds': [-180.0, -90.0, 180.0, 90.0],\n 'center': (0.0, 0.0, 1),\n 'tiles': {}}\n</code></pre> <pre><code>mosaic_definition = dict(\n    mosaicjson=\"0.0.2\",\n    minzoom=1,\n    maxzoom=100,\n    quadkey_zoom=1,\n    bounds=[-180, -90, 180, 90],\n    center=(0, 0, 1),\n    tiles={},\n)\n\nm = MosaicJSON(**mosaic_definition)\n...\nValidationError: 1 validation error for MosaicJSON\nmaxzoom\n  ensure this value is less than or equal to 30 (type=value_error.number.not_le; limit_value=30)\n</code></pre>"},{"location":"v3_migration/#creation","title":"Creation","text":"<p>The <code>MosaicJSON</code> class comes also with helper functions: - MosaicJSON.from_urls: Create a mosaicjson from a set of COG urls - MosaicJSON.from_features: Create a mosaicjson from a set of GeoJSON features - MosaicJSON._create_mosaic (semi-private): Low level mosaic creation methods used by public methods (<code>from_urls</code> and <code>from_features</code>).</p> <pre><code>#V2\nfrom cogeo_mosaic.utils import create_mosaic\n\nmosaic_definition: Dict = create_mosaic(dataset)\n\n\n#V3\nfrom cogeo_mosaic.mosaic import MosaicJSON\n\nmosaic_definition: MosaicJSON = MosaicJSON.from_urls(dataset)\n\n# or from a list of GeoJSON Features\nmosaic_definition: MosaicJSON = MosaicJSON.from_features(dataset, minzoom=1, maxzoom=3)\n</code></pre> <p>To learn more about the low-level api checkout /docs/AdvancedTopics.md</p>"},{"location":"v3_migration/#backend-storage","title":"Backend Storage","text":""},{"location":"v3_migration/#read","title":"Read","text":"<pre><code># V2\nfrom cogeo_mosaic.utils import (\n    fetch_mosaic_definition,\n    fetch_and_find_assets,\n    fetch_and_find_assets_point,\n)\nmosaic_definition = fetch_mosaic_definition(url)\nassets = fetch_and_find_assets(url, x, y, z)\nassets = fetch_and_find_assets_point(url, lng, lat)\n\n\n# V3\nfrom cogeo_mosaic.backends import MosaicBackend\n\nwith MosaicBackend(url) as mosaic:\n    mosaic_definition = mosaic.mosaic_def\n    assets = mosaic.tile(x, y, z)    # LRU cache\n    assets = mosaic.point(lng, lat)  # LRU cache\n</code></pre>"},{"location":"v3_migration/#write","title":"Write","text":"<pre><code>#V2\nfrom cogeo_mosaic.utils import create_mosaic\nfrom boto3.session import Session as boto3_session\n\nmosaic_definition = create_mosaic(dataset)\n\ndef _compress_gz_json(data):\n    gzip_compress = zlib.compressobj(9, zlib.DEFLATED, zlib.MAX_WBITS | 16)\n\n    return (\n        gzip_compress.compress(json.dumps(data).encode(\"utf-8\")) + gzip_compress.flush()\n    )\n\nsession = boto3_session()\nclient = session.client(\"s3\")\nclient.put_object(\n    Bucket=bucket,\n    Key=key,\n    Body=_compress_gz_json(mosaic_definition),\n)\n\n#V3\nfrom cogeo_mosaic.mosaic import MosaicJSON\n\nmosaic_definition = MosaicJSON.from_urls(dataset)\n\nwith MosaicBackend(\"s3://{bucket}/{key}\", mosaic_def=mosaic_definition) as mosaic:\n    mosaic.write()\n</code></pre>"},{"location":"v6_migration/","title":"cogeo-mosaic 5.0 to 6.0 migration guide","text":""},{"location":"v6_migration/#mosaicjson-specification-003","title":"MosaicJSON specification <code>0.0.3</code>","text":"<p>Starting with <code>6.0</code>, cogeo-mosaic will follow the MosaicJSON <code>0.0.3</code> specification (changes). Old mosaic files should still be usable.</p> <p>If updating a previous mosaic file, a warning should be printed.</p>"},{"location":"v6_migration/#multiple-tilematrixsets-support-create","title":"Multiple TileMatrixSets support (create)","text":"<p>Following specification <code>0.0.3</code>, we can now create Mosaics using other TileMatrixSet than the default <code>WebMercatorQuad</code>.</p> <pre><code>import morecantile\nfrom cogeo_mosaic.mosaic import MosaicJSON\n\ntms_5041 = morecantile.tms.get(\"UPSArcticWGS84Quad\")\nmosaic = MosaicJSON.from_urls([...], tilematrixset=tms_5041)\nassert mosaic.tilematrixset.id == \"UPSArcticWGS84Quad\"\n</code></pre>"},{"location":"v6_migration/#multiple-tilematrixsets-support-in-backend-read","title":"Multiple TileMatrixSets support in Backend (read)","text":"<p>You can now pass <code>TileMatrixSet</code> as input parameters to MosaicBackend to read tiles in other TileMatrixSet than the default <code>WebMercatorQuad</code>.</p> <pre><code>import morecantile\nfrom cogeo_mosaic.backends import MosaicBackend\n\ntms = morecantile.tms.get(\"WGS1984Quad\")\nwith MosaicBackend(mosaic_path, tms=tms) as mosaic:\n    img, assets = mosaic.tile(1, 2, 3)\n    assert img.crs == \"epsg:4326\"\n</code></pre> <p>Note: When passing a different TileMatrixSet than the mosaic's TileMatrixSet, the <code>minzoom/maxzoom</code> will default to the TileMatrixSet levels.</p>"},{"location":"advanced/backends/","title":"Backends","text":"<p>Starting in version <code>3.0.0</code>, we introduced specific <code>backend</code> to abstract mosaicJSON storage.</p>"},{"location":"advanced/backends/#read-write-backends","title":"Read-Write Backends","text":"<ul> <li> <p>FileBackend (default, <code>file:///</code>)</p> </li> <li> <p>S3Backend (<code>s3://</code>)</p> </li> <li> <p>GCSBackend (<code>gs://</code>)</p> </li> <li> <p>ABSBackend (<code>az://{storageaccount}.blob.core.windows.net/{container}/{key}</code>)</p> </li> <li> <p>DynamoDBBackend (<code>dynamodb://{region}/{table_name}</code>). If <code>region</code> is not passed, it reads the value of the <code>AWS_REGION</code> environment variable. If that environment variable does not exist, it falls back to <code>us-east-1</code>. If you choose not to pass a <code>region</code>, you still need three <code>/</code> before the table name, like so <code>dynamodb:///{table_name}</code>.</p> </li> <li> <p>SQLiteBackend (<code>sqlite:///{file.db}:{mosaic_name}</code>)</p> </li> </ul>"},{"location":"advanced/backends/#read-only-backends","title":"Read Only Backends","text":"<p>Read only backend won't allow <code>mosaic_def</code> in there <code>__init__</code> method. <code>.write()</code> and <code>.update</code> methods will raise <code>NotImplementedError</code> error.</p> <ul> <li>HttpBackend (<code>http://</code>, <code>https://</code>)</li> <li>STACBackend (<code>stac+:https://</code>). Based on SpatioTemporal Asset Catalog API.</li> </ul>"},{"location":"advanced/backends/#in-memory","title":"In-Memory","text":"<p>If you have a mosaicjson document and want to use the different backend methods you can use the special MemoryBackend.</p> <pre><code>with MemoryBackend(mosaic_def=mosaicjson) as mosaic:\n    img = mosaic.tile(1, 1, 1)\n</code></pre>"},{"location":"advanced/backends/#abstract-class","title":"Abstract Class","text":"<p>All backends are built from a <code>MosaicJSONBackend</code> which is a sub-class or <code>rio-tiler.mosaic.backend.BaseBackend</code>.</p>"},{"location":"advanced/backends/#mosaicbackend","title":"MosaicBackend","text":"<p>To ease the usage we added a helper function to use the right backend based on the uri schema: <code>cogeo_mosaic.backends.MosaicBackend</code></p> <pre><code>from cogeo_mosaic.backends import MosaicBackend\n\nwith MosaicBackend(\"s3://mybucket/amosaic.json\") as mosaic:\n    assert isinstance(mosaic, cogeo_mosaic.backends.s3.S3Backend)\n\nwith MosaicBackend(\"gs://mybucket/amosaic.json\") as mosaic:\n    assert isinstance(mosaic, cogeo_mosaic.backends.gs.GCSBackend)\n\nwith MosaicBackend(\"dynamodb://us-east-1/amosaic\") as mosaic:\n    assert isinstance(mosaic, cogeo_mosaic.backends.dynamodb.DynamoDBBackend)\n\nwith MosaicBackend(\"sqlite:///mosaic.db:amosaic\") as mosaic:\n    assert isinstance(mosaic, cogeo_mosaic.backends.sqlite.SQLiteBackend)\n\nwith MosaicBackend(\"file:///amosaic.json.gz\") as mosaic:\n    assert isinstance(mosaic, cogeo_mosaic.backends.file.FileBackend)\n\nwith MosaicBackend(\"amosaic.json.gz\") as mosaic:\n    assert isinstance(mosaic, cogeo_mosaic.backends.file.FileBackend)\n\n# Read-Only\nwith MosaicBackend(\"https://mosaic.com/amosaic.json.gz\") as mosaic:\n    assert isinstance(mosaic, cogeo_mosaic.backends.web.HttpBackend)\n\nwith MosaicBackend(\"stac+https://my-stac.api/search\", {\"collections\": [\"satellite\"]}, 10, 12) as mosaic:\n    assert isinstance(mosaic, cogeo_mosaic.backends.stac.STACBackend)\n\n# In Memory (write)\n# You can pass either None or ':memory:' to define an in-memory backend\nwith MosaicBackend(\":memory:\", mosaic_def=mosaic) as mosaic:\n    assert isinstance(mosaic, cogeo_mosaic.backends.memory.MemoryBackend)\n\nwith MosaicBackend(None, mosaic_def=mosaic) as mosaic:\n    assert isinstance(mosaic, cogeo_mosaic.backends.memory.MemoryBackend)\n</code></pre>"},{"location":"advanced/backends/#gcs-backend","title":"GCS Backend","text":"<p>The GCS Backend allows read and write operations from Google Cloud Storage.</p> <p>When using this backend is necessary to set the appropriate roles and IAM permissions to let cogeo-mosaic access the files. For example:</p> <ul> <li>Read-only bucket - IAM Role <code>roles/storage.objectViewer</code>. It is possible   to restrict the read-only operation to a single bucket by using the   following condition: <code>resource.type == \"storage.googleapis.com/Object\"   &amp;&amp; resource.name.startsWith(\"projects/_/buckets/mybucket\")</code></li> </ul>"},{"location":"advanced/backends/#abs-backend","title":"ABS Backend","text":"<p>The ABS Backend allows read and write operations from/to Azure Blob Storage.</p> <p>The backend uses DefaultAzureCredential for authorization, see here for details on how to authenticate.</p> <p>When using this backend is necessary to set the appropriate roles and IAM permissions to let cogeo-mosaic access the files. See the Azure standard roles; Storage Blob Data Contributor/Owner/Reader.</p>"},{"location":"advanced/backends/#stac-backend","title":"STAC Backend","text":"<p>The STACBackend is a read-only backend, meaning it can't be used to write a file. This backend will POST to the input url looking for STAC items which will then be used to create the mosaicJSON in memory.</p> <pre><code>import datetime\nimport morecantile\nfrom cogeo_mosaic.backends.stac import STACBackend\n\n\ngeojson = {\n  \"type\": \"FeatureCollection\",\n  \"features\": [\n    {\n      \"type\": \"Feature\",\n      \"properties\": {},\n      \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [\n          [\n            [\n              30.810813903808594,\n              29.454247067148533\n            ],\n            [\n              30.88600158691406,\n              29.454247067148533\n            ],\n            [\n              30.88600158691406,\n              29.51879923863822\n            ],\n            [\n              30.810813903808594,\n              29.51879923863822\n            ],\n            [\n              30.810813903808594,\n              29.454247067148533\n            ]\n          ]\n        ]\n      }\n    }\n  ]\n}\n\n\ndate_min=\"2019-01-01\"\ndate_max=\"2019-12-11\"\n\nstart = datetime.datetime.strptime(date_min, \"%Y-%m-%d\").strftime(\"%Y-%m-%dT00:00:00Z\")\nend = datetime.datetime.strptime(date_max, \"%Y-%m-%d\").strftime(\"%Y-%m-%dT23:59:59Z\")\n\nquery = {\n    \"collections\": [\"sentinel-s2-l2a-cogs\"],\n    \"datetime\": f\"{start}/{end}\",\n    \"query\": {\n        \"eo:cloud_cover\": {\n            \"lt\": 5\n        }\n    },\n    \"intersects\": geojson[\"features\"][0][\"geometry\"],\n    \"limit\": 1000,\n    \"fields\": {\n      'include': ['id', 'properties.datetime', 'properties.data_coverage'],\n      'exclude': ['assets']\n    }\n}\n\nwith STACBackend(\n    \"https://earth-search.aws.element84.com/v0/search\",\n    query=query,\n    minzoom=8,\n    maxzoom=15,\n) as mosaic:\n    print(mosaic.mosaic_def.dict(exclude={\"tiles\"}))\n</code></pre>"},{"location":"advanced/backends/#mosaic-tilematrixset-vs-backend-tilematrixset","title":"Mosaic TileMatrixSet vs Backend TileMatrixSet","text":"<p>If using a TileMatrixSet other than the default <code>WebMercatorQuad</code>, user HAS TO pass mosaic min/max zoom (different than the backend min/max zoom).</p> <pre><code>with STACBackend(\n    \"https://earth-search.aws.element84.com/v0/search\",\n    query=query,\n    tms=morecantile.tms.get(\"WGS1984Quad\"),\n    minzoom=8,\n    maxzoom=12,\n    mosaic_options={\n        \"tilematrixset\": morecantile.tms.get(\"WebMercatorQuad\"),  # This is Optional and will be set by default to `WebMercatorQuad` TMS\n        \"minzoom\": 8,\n        \"maxzoom\": 14,\n    },\n) as mosaic:\n    print(mosaic.mosaic_def.dict(exclude={\"tiles\"}))\n</code></pre>"},{"location":"advanced/backends/#specification","title":"Specification","text":"<p>The STACBackend rely on Spec version 1.0.0alpha.</p>"},{"location":"advanced/backends/#paggination","title":"Paggination","text":"<p>The returned object from the POST requests might not represent the whole results and thus we need to use the paggination.</p> <p>You can limit the pagination by using <code>max_items</code> or <code>limit</code> stac-api options.</p> <ul> <li>Limit the total result to 1000 items</li> </ul> <pre><code>with STACBackend(\n    \"https://earth-search.aws.element84.com/v0/search\",\n    query={},\n    minzoom=8,\n    maxzoom=15,\n    stac_api_options={\"max_items\": 1000},\n) as mosaic:\n    print(mosaic.mosaic_def.dict(exclude={\"tiles\"}))\n</code></pre> <ul> <li>Limit the size of each POST result</li> </ul> <p><pre><code>with STACBackend(\n    \"https://earth-search.aws.element84.com/v0/search\",\n    query={},\n    minzoom=8,\n    maxzoom=15,\n    stac_api_options={\"limit\": 100},\n) as mosaic:\n    print(mosaic.mosaic_def.dict(exclude={\"tiles\"}))\n</code></pre> Warnings: trying to run the previous example will results in fetching the whole collection.</p>"},{"location":"advanced/backends/#tiles-asset","title":"Tile's asset","text":"<p>MosaicJSON tile asset is defined using <code>accessor</code> option. By default the backend will try to construct or retrieve the Item url</p> <pre><code>def default_stac_accessor(feature: Dict):\n    \"\"\"Return feature identifier.\"\"\"\n    link = list(filter(lambda link: link[\"rel\"] == \"self\", feature[\"links\"]))\n    if link:\n        return link[0][\"href\"]\n\n    link = list(filter(lambda link: link[\"rel\"] == \"root\", feature[\"links\"]))\n    if link:\n        return os.path.join(\n            link[0][\"href\"],\n            \"collections\",\n            feature[\"collection\"],\n            \"items\",\n            feature[\"id\"],\n        )\n\n    # Fall back to the item ID\n    return feature[\"id\"]\n</code></pre> <p>This default accessor function rely on the <code>self</code> or <code>root</code> link to be present.</p> <p>It's let to the user to built a Mosaic Tiler which will understand the asset.</p>"},{"location":"advanced/backends/#custom-accessor","title":"Custom accessor","text":"<p>Accessor HAVE to be a callable which take a GeoJSON feature as input.</p> <p>Here is an example of an accessor that will return the ulr for asset <code>B01</code></p> <pre><code>with STACBackend(\n    \"https://earth-search.aws.element84.com/v0/search\",\n    query={},\n    minzoom=8,\n    maxzoom=15,\n    stac_api_options={\"limit\": 100},\n    mosaic_options={\"accessor\": lambda x: x[\"assets\"][\"B01\"][\"href\"]},\n) as mosaic:\n    print(mosaic.mosaic_def.dict(exclude={\"tiles\"}))\n</code></pre>"},{"location":"advanced/custom/","title":"Customization","text":""},{"location":"advanced/custom/#custom-mosaic-creation","title":"Custom mosaic creation","text":"<p><code>MosaicJSON._create_mosaic()</code> method is the low level method that creates mosaicjson document. It has multiple required arguments and options with default values which more advanced users would change.</p> <pre><code># cogeo_mosaic.mosaic.MosaicJSON._create_mosaic\ndef _create_mosaic(\n    cls,\n    features: Sequence[Dict],\n    minzoom: int,\n    maxzoom: int,\n    quadkey_zoom: Optional[int] = None,\n    accessor: Callable[[Dict], str] = default_accessor,\n    asset_filter: Callable = default_filter,\n    version: str = \"0.0.3\",\n    tilematrixset: Optional[morecantile.TileMatrixSet] = None,\n    asset_type: Optional[str] = None,\n    asset_prefix: Optional[str] = None,\n    data_type: Optional[str] = None,\n    colormap: Optional[Dict[int, Tuple[int, int, int, int]]] = None,\n    layers: Optional[Dict] = None,\n    quiet: bool = True,\n    **kwargs,\n):\n</code></pre>"},{"location":"advanced/custom/#custom-accessor","title":"Custom Accessor","text":"<p>MosaicJSON <code>create</code> method takes a list of GeoJSON features has input, those can be the output of cogeo_mosaic.utils.get_footprints or can be provided by the user (e.g STAC items). MosaicJSON defines it's tile assets as a <code>MUST be arrays of strings (url or sceneid) pointing to a COG</code>. To access those values, <code>_create_mosaic</code> needs to know which property to read from the GeoJSON feature.</p> <p>The accessor option is here to enable user to pass their own accessor model. By default, <code>_create_mosaic</code> expect features from <code>get_footprints</code> and thus COG path stored in <code>feature[\"properties\"][\"path\"]</code>.</p> <p>Example:</p> <pre><code>from cogeo_mosaic.mosaic import MosaicJSON\n\nfeatures = [{\"url\": \"1.tif\", \"geometry\": {...}}, {\"url\": \"2.tif\", \"geometry\": {...}}]\nminzoom = 1\nmaxzoom = 6\n\ncustom_id = lambda feature: feature[\"url\"]\n\n# 'from_features' will pass all args and kwargs to '_create_mosaic'\nmosaicjson = MosaicJSON.from_features(\n    features,\n    minzoom,\n    maxzoom,\n    accessor=custom_id,\n)\n</code></pre>"},{"location":"advanced/custom/#custom-asset-filtering","title":"Custom asset filtering","text":"<p>On mosaicjson creation ones would want to perform more advanced assets filtering or sorting. To enable this, users can define their own <code>filter</code> method and pass it using the <code>asset_filter</code> options.</p> <p>!!! In the current implementation, <code>asset_filter</code> method have to allow at least 3 arguments: - tile - morecantile.Tile: Morecantile tile - dataset - Sequence[Dict]: GeoJSON Feature list intersecting with the <code>tile</code> - geoms - Sequence[polygons]: Geos Polygon list for the features</p> <p>Example:</p> <pre><code>import datetime\nfrom cogeo_mosaic.mosaic import MosaicJSON, default_filter\n\nfeatures = [{\"url\": \"20190101.tif\", \"geometry\": {...}}, {\"url\": \"20190102.tif\", \"geometry\": {...}}]\nminzoom = 1\nmaxzoom = 6\n\ndef custom_filter(**args, **kwargs):\n    \"\"\"Default filter + sort.\"\"\"\n    dataset = default_filter(**args, **kwargs)\n    return sorted(\n        dataset,\n        key=lambda x: datetime.datetime.strptime(x[\"url\"].split(\".\")[0], \"%Y%m%d\")\n    )\n\nmosaicjson = MosaicJSON.from_features(\n    features,\n    minzoom,\n    maxzoom,\n    asset_filter=custom_filter,\n)\n</code></pre>"},{"location":"advanced/custom/#custom-mosaic-update","title":"Custom mosaic update","text":"<p>Update method is backend specific because you don't write a mosaicjson document in the same way in AWS S3 and in AWS DynamoDB.</p> <p>The main method is defined in cogeo_mosaic.backends.base.BaseBackend.</p> <p>On update, here is what is happening: 1. create mosaic with the new dataset 2. loop through the new <code>quadkeys</code> and edit <code>old</code> mosaic assets 3. update bounds, center and version of the updated mosaic 4. write the mosaic</p> <pre><code># cogeo_mosaic.backends.base.BaseBackend\ndef update(\n    self,\n    features: Sequence[Dict],\n    add_first: bool = True,\n    quiet: bool = False,\n    **kwargs,\n):\n    \"\"\"Update existing MosaicJSON on backend.\"\"\"\n    # Create mosaic with the new features\n    new_mosaic = self.mosaic_def.from_features(\n        features,\n        self.mosaic_def.minzoom,\n        self.mosaic_def.maxzoom,\n        tilematrixset=self.mosaic_def.tilematrixset,\n        quadkey_zoom=self.quadkey_zoom,\n        quiet=quiet,\n        **kwargs,\n    )\n\n    # Loop through the new `quadkeys` and edit `old` mosaic assets\n    for quadkey, new_assets in new_mosaic.tiles.items():\n        tile = self.tms.quadkey_to_tile(quadkey)\n        assets = self.tile(*tile)\n        assets = [*new_assets, *assets] if add_first else [*assets, *new_assets]\n\n        # [PLACEHOLDER] add custom sorting algorithm (e.g based on path name)\n        self.mosaic_def.tiles[quadkey] = assets\n\n    # Update bounds, center and version of the updated mosaic\n    bounds = bbox_union(new_mosaic.bounds, self.mosaic_def.bounds)\n    self.mosaic_def._increase_version() # Increate mosaicjson document version\n    self.mosaic_def.bounds = bounds\n    self.mosaic_def.center = (\n        (bounds[0] + bounds[2]) / 2,\n        (bounds[1] + bounds[3]) / 2,\n        self.mosaic_def.minzoom,\n    )\n\n    # Write the mosaic\n    if self.input:\n        self.write()\n\n    return\n</code></pre> <p>Sometime you'll will want to do more advanced filtering/sorting with the newly dataset stack (e.g keep a max number of COG). For this you'll need to create custom backend:</p> <pre><code>from cogeo_mosaic.backends.s3 import S3Backend\nimport morecantile\n\nclass CustomS3Backend(S3Backend):\n\n    _backend_name = \"Custom AWS S3\"\n\n    def update(\n        self,\n        features: Sequence[Dict],\n        quiet: bool = False,\n        max_image: int = 5,\n        **kwargs,\n    ):\n        \"\"\"Update existing MosaicJSON on backend.\"\"\"\n        new_mosaic = self.mosaic_def.from_features(\n            features,\n            self.mosaic_def.minzoom,\n            self.mosaic_def.maxzoom,\n            quadkey_zoom=self.quadkey_zoom,\n            quiet=quiet,\n            **kwargs,\n        )\n\n        mosaic_tms = self.mosaic_def.tilematrixset or morecantile.tms.get(\"WebMercatorQuad\")\n        for quadkey, new_assets in new_mosaic.tiles.items():\n            tile = mosaic_tms.quadkey_to_tile(quadkey)\n            assets = self.tile(*tile)\n            assets = [*new_assets, *assets]\n\n            self.mosaic_def.tiles[quadkey] = assets[:maximum_items_per_tile]\n\n        bounds = bbox_union(new_mosaic.bounds, self.mosaic_def.bounds)\n        self.mosaic_def._increase_version() # Increate mosaicjson document version\n        self.mosaic_def.bounds = bounds\n        self.mosaic_def.center = (\n            (bounds[0] + bounds[2]) / 2,\n            (bounds[1] + bounds[3]) / 2,\n            self.mosaic_def.minzoom,\n        )\n\n        self.write()\n\n        return\n</code></pre>"},{"location":"advanced/dynamic/","title":"Dynamic Backends","text":"<p>Deprecated: With rio-tiler 8.0, creating dynamtic mosaic backend doesn't need to be done with the <code>MosaicJSONBaseBackend</code>. See cogeotiff.github.io/rio-tiler/advanced/mosaic_backend/.</p> <p>The mosaic backend abstract <code>MosaicJSONBaseBackend</code> has been designed to be really flexible and compatible with dynamic tiler built for rio-tiler <code>BaseReader</code>. It also enables the creation of <code>dynamic</code> mosaic where NO mosaicJSON document really exists.</p> <p>The <code>MosaicJSONBaseBackend</code> ABC class defines that the sub class should:</p> <ul> <li>have a <code>mosaic_def</code> object (MosaicJSON) or a path as input</li> <li>have <code>_read</code>, <code>write</code> and <code>update</code> methods defined</li> </ul> <p>Other attributes can default to the BaseBackend defaults:</p> <ul> <li><code>tms</code> is set to WebMercator</li> <li><code>minzoom</code> is set to <code>0</code> (mosaicJSON default)</li> <li><code>maxzoom</code> is set to <code>30</code> (mosaicJSON default)</li> <li><code>bounds</code> is set to <code>(-180, -90, 180, 90)</code>  (mosaicJSON default)</li> </ul> <p>all other methods are built on top of the MosaicJSON definition.</p> <p>For a <code>dynamic</code> backend we do not want to construct nor store a mosaicJSON object but fetch the <code>assets</code> needed on each <code>tile()</code> or <code>point()</code> request.</p> <p>For this to be possible we need to :</p> <ul> <li>create a <code>fake</code> empty mosaicJSON</li> <li>create passthrough <code>_read</code>, <code>write</code> and <code>update</code> methods</li> <li>create custom <code>get_assets()</code>, <code>assets_for_tile()</code> and <code>assets_for_point()</code> methods.</li> </ul> <p>Here is an example of a <code>Dynamic</code> STAC backend where on each <code>tile()</code> or <code>point()</code> call, the backend will send a request to the STAC api endpoint to find the assets interesecting with the request.</p> <pre><code>from typing import Dict, Tuple, Type, Optional, List\n\nimport attr\nimport morecantile\nfrom rasterio.crs import CRS\nfrom rio_tiler.constants import WEB_MERCATOR_TMS, WGS84_CRS\nfrom rio_tiler.io import BaseReader\nfrom rio_tiler.io import STACReader\n\nfrom cogeo_mosaic.backends.base import MosaicJSONBaseBackend\nfrom cogeo_mosaic.backends.stac import _fetch, default_stac_accessor\nfrom cogeo_mosaic.mosaic import MosaicJSON\n\n\n@attr.s\nclass DynamicStacBackend(MosaicJSONBaseBackend):\n    \"\"\"Like a STAC backend but dynamic\"\"\"\n\n    # input should be the STAC-API url\n    input: str = attr.ib()\n\n    # Addition required attribute (STAC Query)\n    query: Dict = attr.ib(factory=dict)\n\n    tms: morecantile.TileMatrixSet = attr.ib(default=WEB_MERCATOR_TMS)\n\n    minzoom: int = attr.ib(default=None)\n    maxzoom: int = attr.ib(default=None)\n\n    reader: Type[BaseReader] = attr.ib(default=STACReader)\n    reader_options: Dict = attr.ib(factory=dict)\n\n    bounds: Tuple[float, float, float, float] = attr.ib(\n        default=(-180, -90, 180, 90)\n    )\n    crs: CRS = attr.ib(default=WGS84_CRS)\n\n    # STAC API related options\n    # max_items |  next_link_key | limit\n    stac_api_options: Dict = attr.ib(factory=dict)\n\n    # The reader is read-only, we can't pass mosaic_def to the init method\n    mosaic_def: MosaicJSON = attr.ib(init=False)\n\n    _backend_name = \"DynamicSTAC\"\n\n    def __attrs_post_init__(self):\n        \"\"\"Post Init.\"\"\"\n        self.minzoom = self.minzoom if self.minzoom is not None else self.tms.minzoom\n        self.maxzoom = self.maxzoom if self.maxzoom is not None else self.tms.maxzoom\n\n        # Construct a FAKE/Empty mosaicJSON\n        # mosaic_def has to be defined. As we do for the DynamoDB and SQLite backend\n        self.mosaic_def = MosaicJSON(\n            mosaicjson=\"0.0.3\",\n            name=\"it's fake but it's ok\",\n            bounds=self.bounds,\n            minzoom=self.minzoom,\n            maxzoom=self.maxzoom,\n            tiles={}  # we set `tiles` to an empty list.\n        )\n\n    def write(self, overwrite: bool = True):\n        \"\"\"This method is not used but is required by the abstract class.\"\"\"\n        raise NotImplementedError\n\n    def update(self):\n        \"\"\"We overwrite the default method.\"\"\"\n        raise NotImplementedError\n\n    def _read(self) -&gt; MosaicJSON:\n        \"\"\"This method is not used but is required by the abstract class.\"\"\"\n        pass\n\n    def assets_for_tile(self, x: int, y: int, z: int) -&gt; List[str]:\n        \"\"\"Retrieve assets for tile.\"\"\"\n        bounds = self.tms.bounds(x, y, z)\n        geom = {\n            \"type\": \"Polygon\",\n            \"coordinates\": [\n                [\n                    [bounds[0], bounds[3]],\n                    [bounds[0], bounds[1]],\n                    [bounds[2], bounds[1]],\n                    [bounds[2], bounds[3]],\n                    [bounds[0], bounds[3]],\n                ]\n            ],\n        }\n        return self.get_assets(geom)\n\n    def assets_for_point(self, lng: float, lat: float) -&gt; List[str]:\n        \"\"\"Retrieve assets for point.\n\n        Note: some API only accept Polygon.\n        \"\"\"\n        EPSILON = 1e-14\n        geom = {\n            \"type\": \"Polygon\",\n            \"coordinates\": [\n                [\n                    [lng - EPSILON, lat + EPSILON],\n                    [lng - EPSILON, lat - EPSILON],\n                    [lng + EPSILON, lat - EPSILON],\n                    [lng + EPSILON, lat + EPSILON],\n                    [lng - EPSILON, lat + EPSILON],\n                ]\n            ],\n        }\n        return self.get_assets(geom)\n\n    def get_assets(self, geom) -&gt; List[str]:\n        \"\"\"Send query to the STAC-API and retrieve assets.\"\"\"\n        query = self.query.copy()\n        query[\"intersects\"] = geom\n\n        features = _fetch(\n            self.input,\n            query,\n            **self.stac_api_options,\n        )\n        return [default_stac_accessor(f) for f in features]\n\n    @property\n    def _quadkeys(self) -&gt; List[str]:\n        return []\n</code></pre> <p>Full examples can be found at examples/Create_a_Dynamic_StacBackend/ and examples/Create_a_Dynamic_RtreeBackend/.</p>"},{"location":"advanced/readers/","title":"Reader","text":""},{"location":"advanced/readers/#cogreader-stacreader","title":"COGReader / STACReader","text":"<p>The MosaicJSON backend classes have <code>.tile</code> and <code>.point</code> methods to access the data for a specific mercator tile or point.</p> <p>Because a MosaicJSON can host different assets type, a <code>reader</code> option is available. Set by default to <code>rio_tiler.io.COGReader</code>, or to <code>rio_tiler.io.STACReader</code> for the STACBackend, the reader should know how to read the assets to either create mosaic tile or read points value.</p> <pre><code>from cogeo_mosaic.mosaic import MosaicJSON\nfrom cogeo_mosaic.backends import MosaicBackend\nfrom rio_tiler.models import ImageData\n\ndataset = [\"1.tif\", \"2.tif\"]\nmosaic_definition = MosaicJSON.from_urls(dataset)\n\n# Create a mosaic object in memory\nwith MosaicBackend(None, mosaid_def=mosaic_definition, reader=COGReader) as mosaic:\n    img, assets_used = mosaic.tile(1, 1, 1)\n    assert isinstance(img, ImageData)\n\n# By default the STACbackend will store the Item url as assets, but STACReader (default reader) will know how to read them.\nwith MosaicBackend(\n  \"stac+https://my-stac.api/search\",\n  query={\"collections\": [\"satellite\"]},  # required\n  minzoom=7,  # required\n  maxzoom=12,  # required\n) as mosaic:\n    img, assets_used = mosaic.tile(1, 1, 1, assets=\"red\")\n</code></pre> <p>Let's use a custom accessor to save some specific assets url in the mosaic</p> <pre><code># accessor to return the url for the `visual` asset (COG)\ndef accessor(item):\n    return feature[\"assets\"][\"visual\"][\"href\"]\n\n# The accessor will set the mosaic assets as a list of COG url so we can use the COGReader instead of the STACReader\nwith MosaicBackend(\n  \"stac+https://my-stac.api/search\",\n  query={\"collections\": [\"satellite\"]},  # required\n  minzoom=7,  # required\n  maxzoom=12,  # required\n  reader=COGReader,\n  mosaic_options={\"accessor\": accessor},\n) as mosaic:\n    img, assets_used = mosaic.tile(1, 1, 1)\n</code></pre>"},{"location":"examples/Create_a_Dynamic_RtreeBackend/","title":"Create a Dynamic RTree backend","text":"In\u00a0[2]: Copied! <pre># Uncomment this line if you need to install the dependencies\n# !pip install cogeo-mosaic rtree shapely tqdm\n</pre> # Uncomment this line if you need to install the dependencies # !pip install cogeo-mosaic rtree shapely tqdm In\u00a0[3]: Copied! <pre>import httpx\nimport pickle\n\nfrom tqdm.notebook import tqdm\n\nfrom rtree import index\n</pre> import httpx import pickle  from tqdm.notebook import tqdm  from rtree import index In\u00a0[4]: Copied! <pre># Download geometry file\nurl = \"https://naipeuwest.blob.core.windows.net/naip-index/rtree/tiles.p\"\nwith httpx.stream(\"GET\", url) as r:\n    r.raise_for_status()\n    with open(\"tiles.p\", \"wb\") as f:\n        for chunk in r.iter_bytes(chunk_size=8192):\n            f.write(chunk)\n\n# Load tile index and create rtree index\nwith open(\"tiles.p\", \"rb\") as f:\n    tile_index = pickle.load(f)\n</pre> # Download geometry file url = \"https://naipeuwest.blob.core.windows.net/naip-index/rtree/tiles.p\" with httpx.stream(\"GET\", url) as r:     r.raise_for_status()     with open(\"tiles.p\", \"wb\") as f:         for chunk in r.iter_bytes(chunk_size=8192):             f.write(chunk)  # Load tile index and create rtree index with open(\"tiles.p\", \"rb\") as f:     tile_index = pickle.load(f) <pre>/var/folders/l9/xz620xfs2s5_38f8ybq4m59w0000gn/T/ipykernel_31305/2877602215.py:11: UserWarning: Unpickling a shapely &lt;2.0 geometry object. Please save the pickle again as this compatibility may be removed in a future version of shapely.\n  tile_index = pickle.load(f)\n</pre> In\u00a0[5]: Copied! <pre># Create the Cheapo Rtree database\n# Make sure naip.dat and naip.idx do not exists\nnaip_index = index.Rtree('naip')\nfor idx, (f, geom) in tqdm(tile_index.items(), total=len(tile_index)):\n    naip_index.insert(idx, geom.bounds, obj=f\"https://naipeuwest.blob.core.windows.net/naip/{f}\")\nnaip_index.close()\n</pre> # Create the Cheapo Rtree database # Make sure naip.dat and naip.idx do not exists naip_index = index.Rtree('naip') for idx, (f, geom) in tqdm(tile_index.items(), total=len(tile_index)):     naip_index.insert(idx, geom.bounds, obj=f\"https://naipeuwest.blob.core.windows.net/naip/{f}\") naip_index.close() <pre>  0%|          | 0/1018253 [00:00&lt;?, ?it/s]</pre> In\u00a0[9]: Copied! <pre>from typing import Dict, List, Callable\n\nimport attr\nimport morecantile\nfrom rio_tiler.constants import WEB_MERCATOR_TMS\n\nfrom cogeo_mosaic.backends.base import MosaicJSONBackend\nfrom cogeo_mosaic.mosaic import MosaicJSON\n\n\n@attr.s\nclass DynamicRtreeBackend(MosaicJSONBackend):\n\n    asset_filter: Callable = attr.ib(default=lambda x: x)\n\n    # The reader is read-only, we can't pass mosaic_def to the init method\n    mosaic_def: MosaicJSON = attr.ib(init=False)\n\n    index = attr.ib(init=False)\n\n    tms: morecantile.TileMatrixSet = attr.ib(default=WEB_MERCATOR_TMS)\n    minzoom: int = attr.ib(default=12)  # we know this by analysing the NAIP data\n    maxzoom: int = attr.ib(default=17)  # we know this by analysing the NAIP data\n\n    _backend_name = \"DynamicSTAC\"\n\n    def __attrs_post_init__(self):\n        \"\"\"Post Init.\"\"\"\n        # Construct a FAKE mosaicJSON\n        # mosaic_def has to be defined. As we do for the DynamoDB and SQLite backend\n        # we set `tiles` to an empty list.\n        self.mosaic_def = MosaicJSON(\n            mosaicjson=\"0.0.3\",\n            name=\"it's fake but it's ok\",\n            minzoom=self.minzoom,\n            maxzoom=self.maxzoom,\n            tiles={},\n            tilematrixset=self.tms\n        )\n        self.index = index.Index(self.input)\n        self.bounds = tuple(self.index.bounds)\n        self.crs = self.tms.rasterio_geographic_crs\n\n    def close(self):\n        \"\"\"Close SQLite connection.\"\"\"\n        self.index.close()\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        \"\"\"Support using with Context Managers.\"\"\"\n        self.close()\n\n    def write(self, overwrite: bool = True):\n        \"\"\"This method is not used but is required by the abstract class.\"\"\"\n        pass\n\n    def update(self):\n        \"\"\"We overwrite the default method.\"\"\"\n        pass\n\n    def _read(self) -&gt; MosaicJSON:\n        \"\"\"This method is not used but is required by the abstract class.\"\"\"\n        pass\n\n    def assets_for_tile(self, x: int, y: int, z: int, **kwargs) -&gt; List[str]:\n        \"\"\"Retrieve assets for tile.\"\"\"\n        bbox = self.tms.bounds(x, y, z)\n        return self.get_assets(bbox)\n\n    def assets_for_point(self, lng: float, lat: float, **kwargs) -&gt; List[str]:\n        \"\"\"Retrieve assets for point.\"\"\"\n        EPSILON = 1e-14\n        bbox = (lng - EPSILON, lat - EPSILON, lng + EPSILON, lat + EPSILON)\n        return self.get_assets(bbox)\n\n    def get_assets(self, bbox) -&gt; List[str]:\n        \"\"\"Find assets.\"\"\"\n        assets = [n.object for n in self.index.intersection(bbox, objects=True)]\n        return self.asset_filter(assets)\n\n    @property\n    def _quadkeys(self) -&gt; List[str]:\n        return []\n</pre> from typing import Dict, List, Callable  import attr import morecantile from rio_tiler.constants import WEB_MERCATOR_TMS  from cogeo_mosaic.backends.base import MosaicJSONBackend from cogeo_mosaic.mosaic import MosaicJSON   @attr.s class DynamicRtreeBackend(MosaicJSONBackend):      asset_filter: Callable = attr.ib(default=lambda x: x)      # The reader is read-only, we can't pass mosaic_def to the init method     mosaic_def: MosaicJSON = attr.ib(init=False)      index = attr.ib(init=False)      tms: morecantile.TileMatrixSet = attr.ib(default=WEB_MERCATOR_TMS)     minzoom: int = attr.ib(default=12)  # we know this by analysing the NAIP data     maxzoom: int = attr.ib(default=17)  # we know this by analysing the NAIP data      _backend_name = \"DynamicSTAC\"      def __attrs_post_init__(self):         \"\"\"Post Init.\"\"\"         # Construct a FAKE mosaicJSON         # mosaic_def has to be defined. As we do for the DynamoDB and SQLite backend         # we set `tiles` to an empty list.         self.mosaic_def = MosaicJSON(             mosaicjson=\"0.0.3\",             name=\"it's fake but it's ok\",             minzoom=self.minzoom,             maxzoom=self.maxzoom,             tiles={},             tilematrixset=self.tms         )         self.index = index.Index(self.input)         self.bounds = tuple(self.index.bounds)         self.crs = self.tms.rasterio_geographic_crs      def close(self):         \"\"\"Close SQLite connection.\"\"\"         self.index.close()      def __exit__(self, exc_type, exc_value, traceback):         \"\"\"Support using with Context Managers.\"\"\"         self.close()      def write(self, overwrite: bool = True):         \"\"\"This method is not used but is required by the abstract class.\"\"\"         pass      def update(self):         \"\"\"We overwrite the default method.\"\"\"         pass      def _read(self) -&gt; MosaicJSON:         \"\"\"This method is not used but is required by the abstract class.\"\"\"         pass      def assets_for_tile(self, x: int, y: int, z: int, **kwargs) -&gt; List[str]:         \"\"\"Retrieve assets for tile.\"\"\"         bbox = self.tms.bounds(x, y, z)         return self.get_assets(bbox)      def assets_for_point(self, lng: float, lat: float, **kwargs) -&gt; List[str]:         \"\"\"Retrieve assets for point.\"\"\"         EPSILON = 1e-14         bbox = (lng - EPSILON, lat - EPSILON, lng + EPSILON, lat + EPSILON)         return self.get_assets(bbox)      def get_assets(self, bbox) -&gt; List[str]:         \"\"\"Find assets.\"\"\"         assets = [n.object for n in self.index.intersection(bbox, objects=True)]         return self.asset_filter(assets)      @property     def _quadkeys(self) -&gt; List[str]:         return []  In\u00a0[10]: Copied! <pre># Get assets for a Tile requests\nwith DynamicRtreeBackend(\"naip\") as mosaic:\n    print(mosaic.assets_for_tile(4684, 6278, 14))\n</pre> # Get assets for a Tile requests with DynamicRtreeBackend(\"naip\") as mosaic:     print(mosaic.assets_for_tile(4684, 6278, 14)) <pre>['https://naipeuwest.blob.core.windows.net/naip/v002/md/2013/md_100cm_2013/38077/m_3807724_nw_18_1_20130924.tif', 'https://naipeuwest.blob.core.windows.net/naip/v002/md/2011/md_100cm_2011/38077/m_3807724_nw_18_1_20110629.tif', 'https://naipeuwest.blob.core.windows.net/naip/v002/md/2015/md_100cm_2015/38077/m_3807724_nw_18_1_20150814.tif', 'https://naipeuwest.blob.core.windows.net/naip/v002/va/2011/va_100cm_2011/38077/m_3807724_nw_18_1_20110530.tif', 'https://naipeuwest.blob.core.windows.net/naip/v002/md/2017/md_100cm_2017/38077/m_3807724_nw_18_1_20170716.tif', 'https://naipeuwest.blob.core.windows.net/naip/v002/md/2018/md_060cm_2018/38077/m_3807724_nw_18_060_20181025.tif', 'https://naipeuwest.blob.core.windows.net/naip/v002/md/2018/md_060cm_2018/38077/m_3807724_ne_18_060_20181019.tif', 'https://naipeuwest.blob.core.windows.net/naip/v002/md/2015/md_100cm_2015/38077/m_3807724_ne_18_1_20150814.tif', 'https://naipeuwest.blob.core.windows.net/naip/v002/md/2011/md_100cm_2011/38077/m_3807724_ne_18_1_20110629.tif', 'https://naipeuwest.blob.core.windows.net/naip/v002/md/2013/md_100cm_2013/38077/m_3807724_ne_18_1_20130924.tif', 'https://naipeuwest.blob.core.windows.net/naip/v002/va/2011/va_100cm_2011/38077/m_3807724_ne_18_1_20110530.tif', 'https://naipeuwest.blob.core.windows.net/naip/v002/md/2017/md_100cm_2017/38077/m_3807724_ne_18_1_20170716.tif', 'https://naipeuwest.blob.core.windows.net/naip/v002/va/2012/va_100cm_2012/38077/m_3807724_ne_18_1_20120511.tif', 'https://naipeuwest.blob.core.windows.net/naip/v002/va/2012/va_100cm_2012/38077/m_3807724_nw_18_1_20120511.tif', 'https://naipeuwest.blob.core.windows.net/naip/v002/va/2014/va_100cm_2014/38077/m_3807724_nw_18_1_20140927.tif', 'https://naipeuwest.blob.core.windows.net/naip/v002/va/2014/va_100cm_2014/38077/m_3807724_ne_18_1_20140927.tif', 'https://naipeuwest.blob.core.windows.net/naip/v002/va/2016/va_100cm_2016/38077/m_3807724_ne_18_1_20160718.tif', 'https://naipeuwest.blob.core.windows.net/naip/v002/va/2016/va_100cm_2016/38077/m_3807724_nw_18_1_20160718.tif', 'https://naipeuwest.blob.core.windows.net/naip/v002/va/2018/va_060cm_2018/38077/m_3807724_ne_18_060_20181019.tif', 'https://naipeuwest.blob.core.windows.net/naip/v002/va/2018/va_060cm_2018/38077/m_3807724_nw_18_060_20181025.tif']\n</pre> <p>The naip dataset has couple overlapping years, to create an optimized mosaic we need to filter the assets.</p> <p>Here is an example of filter function which takes the latest data and highest resolution first.</p> In\u00a0[11]: Copied! <pre>import pathlib\n\ndef latest_naip_asset(assets: List[str]) -&gt; List[str]:\n\n    def get_info(asset) -&gt; Dict:\n        parts = pathlib.Path(asset).parts\n        capture_date = parts[-1].split(\"_\")[-1].rstrip(\".tif\")\n        resolution = int(parts[-3].split(\"_\")[1].rstrip(\"cm\"))\n        fname_parts = parts[-1].split(\"_\")\n        quadrangle = f\"{fname_parts[1]}_{fname_parts[2]}_{fname_parts[3]}\"\n\n        return {\n            \"path\": asset,\n            \"capture_date\": capture_date,\n            \"quadrangle\": quadrangle,\n            \"resolution\": resolution\n        }\n\n    asset_info = [get_info(f) for f in assets]\n\n    # Sort by resolution and by dates\n    asset_info = sorted(\n        asset_info, key=lambda item: (item[\"capture_date\"], -item[\"resolution\"]),\n        reverse=True\n    )\n\n    quad = []\n    out_dataset = []\n    for d in asset_info:\n        q = d[\"quadrangle\"]\n        if q not in quad:\n            out_dataset.append(d[\"path\"])\n            quad.append(q)\n\n    return out_dataset\n</pre> import pathlib  def latest_naip_asset(assets: List[str]) -&gt; List[str]:      def get_info(asset) -&gt; Dict:         parts = pathlib.Path(asset).parts         capture_date = parts[-1].split(\"_\")[-1].rstrip(\".tif\")         resolution = int(parts[-3].split(\"_\")[1].rstrip(\"cm\"))         fname_parts = parts[-1].split(\"_\")         quadrangle = f\"{fname_parts[1]}_{fname_parts[2]}_{fname_parts[3]}\"          return {             \"path\": asset,             \"capture_date\": capture_date,             \"quadrangle\": quadrangle,             \"resolution\": resolution         }      asset_info = [get_info(f) for f in assets]      # Sort by resolution and by dates     asset_info = sorted(         asset_info, key=lambda item: (item[\"capture_date\"], -item[\"resolution\"]),         reverse=True     )      quad = []     out_dataset = []     for d in asset_info:         q = d[\"quadrangle\"]         if q not in quad:             out_dataset.append(d[\"path\"])             quad.append(q)      return out_dataset  In\u00a0[12]: Copied! <pre>with DynamicRtreeBackend(\"naip\", asset_filter=latest_naip_asset) as mosaic:\n    print(mosaic.assets_for_tile(4684, 6278, 14))\n</pre> with DynamicRtreeBackend(\"naip\", asset_filter=latest_naip_asset) as mosaic:     print(mosaic.assets_for_tile(4684, 6278, 14)) <pre>['https://naipeuwest.blob.core.windows.net/naip/v002/md/2018/md_060cm_2018/38077/m_3807724_nw_18_060_20181025.tif', 'https://naipeuwest.blob.core.windows.net/naip/v002/md/2018/md_060cm_2018/38077/m_3807724_ne_18_060_20181019.tif']\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/Create_a_Dynamic_RtreeBackend/#create-a-dynamic-rtree-backend","title":"Create a Dynamic RTree backend\u00b6","text":"<p>By default cogeo-mosaic backends were meant to handle writing and reading mosaicjson either from a file or from a database.</p> <p>While this is fine for most use cases, some users could want something more <code>dynamic</code>. In this Notebook we will show how to create a Dynamic mosaic backend based on RTree (https://rtree.readthedocs.io/en/latest/tutorial.html#using-rtree-as-a-cheapo-spatial-database).</p>"},{"location":"examples/Create_a_Dynamic_RtreeBackend/#requirements","title":"Requirements\u00b6","text":"<p>To be able to run this notebook you'll need the following requirements:</p> <ul> <li>cogeo-mosaic</li> <li>rtree</li> <li>shapely</li> <li>tqdm</li> </ul>"},{"location":"examples/Create_a_Dynamic_RtreeBackend/#1-create-the-rtree-index","title":"1. Create the rtree Index\u00b6","text":"<p>Ref: https://azure.microsoft.com/en-us/services/open-datasets/catalog/naip/?tab=data-access#AzureNotebooks</p> <p>Azure is hosting a RTree index (tile_index) and a binary file with all the Naip geometry (tiles.p)</p> <p>binary: https://naipeuwest.blob.core.windows.net/naip-index/rtree/tiles.p Rtree: https://naipeuwest.blob.core.windows.net/naip-index/rtree/tile_index.dat and https://naipeuwest.blob.core.windows.net/naip-index/rtree/tile_index.idx</p> <p>Sadly the Rtree contains only the Indexes, which then has to be used to retrieve the path and geometry in <code>tiles.p</code></p> <p>For this Demo we need to store the information directly in the Rtree object</p>"},{"location":"examples/Create_a_Dynamic_RtreeBackend/#2-create-backend","title":"2. Create backend\u00b6","text":""},{"location":"examples/Create_a_Dynamic_StacBackend/","title":"Create a Dynamic STAC backend","text":"In\u00a0[1]: Copied! <pre># Uncomment this line if you need to install the dependencies\n# !pip install cogeo-mosaic\n</pre> # Uncomment this line if you need to install the dependencies # !pip install cogeo-mosaic In\u00a0[1]: Copied! <pre>from typing import Any, Dict, Tuple, Type, Optional, List\n\nimport attr\nimport morecantile\nfrom rasterio.crs import CRS\nfrom rio_tiler.constants import WEB_MERCATOR_TMS, WGS84_CRS\nfrom rio_tiler.io import BaseReader\nfrom rio_tiler.io import STACReader\n\nfrom cogeo_mosaic.backends.base import MosaicJSONBackend\nfrom cogeo_mosaic.backends.stac import _fetch, default_stac_accessor\nfrom cogeo_mosaic.mosaic import MosaicJSON\n\n\n@attr.s\nclass DynamicStacBackend(MosaicJSONBackend):\n    \"\"\"Like a STAC backend but dynamic\"\"\"\n\n    # input should be the STAC-API url\n    input: str = attr.ib()\n\n    # Addition required attribute (STAC Query)\n    query: Dict = attr.ib(factory=dict)\n\n    tms: morecantile.TileMatrixSet = attr.ib(default=WEB_MERCATOR_TMS)\n\n    minzoom: int = attr.ib(default=None)\n    maxzoom: int = attr.ib(default=None)\n\n    reader: Type[BaseReader] = attr.ib(default=STACReader)\n    reader_options: Dict = attr.ib(factory=dict)\n\n    bounds: Tuple[float, float, float, float] = attr.ib(\n        default=(-180, -90, 180, 90)\n    )\n    crs: CRS = attr.ib(default=WGS84_CRS)\n\n    # STAC API related options\n    # max_items |  next_link_key | limit\n    stac_api_options: Dict = attr.ib(factory=dict)\n\n    # The reader is read-only, we can't pass mosaic_def to the init method\n    mosaic_def: MosaicJSON = attr.ib(init=False)\n\n    _backend_name = \"DynamicSTAC\"\n\n    def __attrs_post_init__(self):\n        \"\"\"Post Init.\"\"\"\n        self.minzoom = self.minzoom if self.minzoom is not None else self.tms.minzoom\n        self.maxzoom = self.maxzoom if self.maxzoom is not None else self.tms.maxzoom\n        \n        # Construct a FAKE/Empty mosaicJSON\n        # mosaic_def has to be defined. As we do for the DynamoDB and SQLite backend\n        self.mosaic_def = MosaicJSON(\n            mosaicjson=\"0.0.3\",\n            name=\"it's fake but it's ok\",\n            bounds=self.bounds,\n            minzoom=self.minzoom,\n            maxzoom=self.maxzoom,\n            tiles={}  # we set `tiles` to an empty list.\n        )\n\n    def write(self, overwrite: bool = True):\n        \"\"\"This method is not used but is required by the abstract class.\"\"\"\n        raise NotImplementedError\n\n    def update(self):\n        \"\"\"We overwrite the default method.\"\"\"\n        raise NotImplementedError\n\n    def _read(self) -&gt; MosaicJSON:\n        \"\"\"This method is not used but is required by the abstract class.\"\"\"\n        pass\n\n    def assets_for_tile(self, x: int, y: int, z: int) -&gt; List[str]:\n        \"\"\"Retrieve assets for tile.\"\"\"\n        bounds = self.tms.bounds(x, y, z)\n        geom = {\n            \"type\": \"Polygon\",\n            \"coordinates\": [\n                [\n                    [bounds[0], bounds[3]],\n                    [bounds[0], bounds[1]],\n                    [bounds[2], bounds[1]],\n                    [bounds[2], bounds[3]],\n                    [bounds[0], bounds[3]],\n                ]\n            ],\n        }\n        return self.get_assets(geom)\n\n    def assets_for_point(self, lng: float, lat: float, **kwargs: Any) -&gt; List[str]:\n        \"\"\"Retrieve assets for point.\n\n        Note: some API only accept Polygon.\n        \"\"\"\n        EPSILON = 1e-14\n        geom = {\n            \"type\": \"Polygon\",\n            \"coordinates\": [\n                [\n                    [lng - EPSILON, lat + EPSILON],\n                    [lng - EPSILON, lat - EPSILON],\n                    [lng + EPSILON, lat - EPSILON],\n                    [lng + EPSILON, lat + EPSILON],\n                    [lng - EPSILON, lat + EPSILON],\n                ]\n            ],\n        }\n        return self.get_assets(geom)\n\n    def get_assets(self, geom) -&gt; List[str]:\n        \"\"\"Send query to the STAC-API and retrieve assets.\"\"\"\n        query = self.query.copy()\n        query[\"intersects\"] = geom\n\n        features = _fetch(\n            self.input,\n            query,\n            **self.stac_api_options,\n        )\n        return [default_stac_accessor(f) for f in features]\n\n    @property\n    def _quadkeys(self) -&gt; List[str]:\n        return []\n</pre> from typing import Any, Dict, Tuple, Type, Optional, List  import attr import morecantile from rasterio.crs import CRS from rio_tiler.constants import WEB_MERCATOR_TMS, WGS84_CRS from rio_tiler.io import BaseReader from rio_tiler.io import STACReader  from cogeo_mosaic.backends.base import MosaicJSONBackend from cogeo_mosaic.backends.stac import _fetch, default_stac_accessor from cogeo_mosaic.mosaic import MosaicJSON   @attr.s class DynamicStacBackend(MosaicJSONBackend):     \"\"\"Like a STAC backend but dynamic\"\"\"      # input should be the STAC-API url     input: str = attr.ib()      # Addition required attribute (STAC Query)     query: Dict = attr.ib(factory=dict)      tms: morecantile.TileMatrixSet = attr.ib(default=WEB_MERCATOR_TMS)      minzoom: int = attr.ib(default=None)     maxzoom: int = attr.ib(default=None)      reader: Type[BaseReader] = attr.ib(default=STACReader)     reader_options: Dict = attr.ib(factory=dict)      bounds: Tuple[float, float, float, float] = attr.ib(         default=(-180, -90, 180, 90)     )     crs: CRS = attr.ib(default=WGS84_CRS)      # STAC API related options     # max_items |  next_link_key | limit     stac_api_options: Dict = attr.ib(factory=dict)      # The reader is read-only, we can't pass mosaic_def to the init method     mosaic_def: MosaicJSON = attr.ib(init=False)      _backend_name = \"DynamicSTAC\"      def __attrs_post_init__(self):         \"\"\"Post Init.\"\"\"         self.minzoom = self.minzoom if self.minzoom is not None else self.tms.minzoom         self.maxzoom = self.maxzoom if self.maxzoom is not None else self.tms.maxzoom                  # Construct a FAKE/Empty mosaicJSON         # mosaic_def has to be defined. As we do for the DynamoDB and SQLite backend         self.mosaic_def = MosaicJSON(             mosaicjson=\"0.0.3\",             name=\"it's fake but it's ok\",             bounds=self.bounds,             minzoom=self.minzoom,             maxzoom=self.maxzoom,             tiles={}  # we set `tiles` to an empty list.         )      def write(self, overwrite: bool = True):         \"\"\"This method is not used but is required by the abstract class.\"\"\"         raise NotImplementedError      def update(self):         \"\"\"We overwrite the default method.\"\"\"         raise NotImplementedError      def _read(self) -&gt; MosaicJSON:         \"\"\"This method is not used but is required by the abstract class.\"\"\"         pass      def assets_for_tile(self, x: int, y: int, z: int) -&gt; List[str]:         \"\"\"Retrieve assets for tile.\"\"\"         bounds = self.tms.bounds(x, y, z)         geom = {             \"type\": \"Polygon\",             \"coordinates\": [                 [                     [bounds[0], bounds[3]],                     [bounds[0], bounds[1]],                     [bounds[2], bounds[1]],                     [bounds[2], bounds[3]],                     [bounds[0], bounds[3]],                 ]             ],         }         return self.get_assets(geom)      def assets_for_point(self, lng: float, lat: float, **kwargs: Any) -&gt; List[str]:         \"\"\"Retrieve assets for point.          Note: some API only accept Polygon.         \"\"\"         EPSILON = 1e-14         geom = {             \"type\": \"Polygon\",             \"coordinates\": [                 [                     [lng - EPSILON, lat + EPSILON],                     [lng - EPSILON, lat - EPSILON],                     [lng + EPSILON, lat - EPSILON],                     [lng + EPSILON, lat + EPSILON],                     [lng - EPSILON, lat + EPSILON],                 ]             ],         }         return self.get_assets(geom)      def get_assets(self, geom) -&gt; List[str]:         \"\"\"Send query to the STAC-API and retrieve assets.\"\"\"         query = self.query.copy()         query[\"intersects\"] = geom          features = _fetch(             self.input,             query,             **self.stac_api_options,         )         return [default_stac_accessor(f) for f in features]      @property     def _quadkeys(self) -&gt; List[str]:         return []  In\u00a0[2]: Copied! <pre>##  Base Query for sat-api\n# - limit of 5 items per page (we will stop at page 1)\n# - less than 25% of cloud\n# - more than 75% of data coverage\n# - `sentinel-s2-l2a-cogs` collection\nquery = {\n    \"collections\": [\"sentinel-s2-l2a-cogs\"],\n    \"limit\": 5,\n    \"query\": {\n        \"eo:cloud_cover\": {\n            \"lt\": 25\n        },\n        \"sentinel:data_coverage\": {\n            \"gt\": 75\n        }\n    },\n    \"fields\": {\n      'include': ['id'],\n      'exclude': ['assets', 'geometry']\n    }\n}\n</pre> ##  Base Query for sat-api # - limit of 5 items per page (we will stop at page 1) # - less than 25% of cloud # - more than 75% of data coverage # - `sentinel-s2-l2a-cogs` collection query = {     \"collections\": [\"sentinel-s2-l2a-cogs\"],     \"limit\": 5,     \"query\": {         \"eo:cloud_cover\": {             \"lt\": 25         },         \"sentinel:data_coverage\": {             \"gt\": 75         }     },     \"fields\": {       'include': ['id'],       'exclude': ['assets', 'geometry']     } } In\u00a0[3]: Copied! <pre># Read Tile\nwith DynamicStacBackend(\n    \"https://earth-search.aws.element84.com/v0/search\",\n    query=query,\n    stac_api_options={\"max_items\": 5},\n    minzoom=8,  # we know this by analysing the sentinel 2 data\n    maxzoom=12,  # we know this by analysing the sentinel 2 data\n) as mosaic:\n    print(mosaic.info())\n    print(len(mosaic.assets_for_tile(535, 335, 10)))\n    img, _ = mosaic.tile(535, 335, 10, assets=\"B01\", tilesize=128, threads=0)\n\nprint(img)\n</pre> # Read Tile with DynamicStacBackend(     \"https://earth-search.aws.element84.com/v0/search\",     query=query,     stac_api_options={\"max_items\": 5},     minzoom=8,  # we know this by analysing the sentinel 2 data     maxzoom=12,  # we know this by analysing the sentinel 2 data ) as mosaic:     print(mosaic.info())     print(len(mosaic.assets_for_tile(535, 335, 10)))     img, _ = mosaic.tile(535, 335, 10, assets=\"B01\", tilesize=128, threads=0)  print(img) <pre>bounds=(-180.0, -90.0, 180.0, 90.0) crs='http://www.opengis.net/def/crs/EPSG/0/4326' name=\"it's fake but it's ok\" quadkeys=[] mosaic_tilematrixset=\"&lt;TileMatrixSet title='Google Maps Compatible for the World' id='WebMercatorQuad' crs='http://www.opengis.net/def/crs/EPSG/0/3857&gt;\" mosaic_minzoom=8 mosaic_maxzoom=12\n5\nImageData(array=masked_array(\n  data=[[[3964, 3867, 4477, ..., 7267, 6752, 6690],\n         [4358, 4450, 4357, ..., 5665, 5759, 5270],\n         [4624, 5443, 5051, ..., 7196, 7560, 6267],\n         ...,\n         [6848, 5832, 5926, ..., 6824, 7578, 5917],\n         [5687, 5581, 5709, ..., 6956, 6578, 6183],\n         [5896, 5798, 5450, ..., 6242, 6246, 6814]]],\n  mask=[[[False, False, False, ..., False, False, False],\n         [False, False, False, ..., False, False, False],\n         [False, False, False, ..., False, False, False],\n         ...,\n         [False, False, False, ..., False, False, False],\n         [False, False, False, ..., False, False, False],\n         [False, False, False, ..., False, False, False]]],\n  fill_value=np.uint64(999999),\n  dtype=uint16), assets=['https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2C_32UMD_20251107_0_L2A'], bounds=BoundingBox(left=900122.445086237, bottom=6887893.4928338025, right=939258.2035682462, top=6927029.2513158135), crs=CRS.from_wkt('PROJCS[\"WGS 84 / Pseudo-Mercator\",GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4326\"]],PROJECTION[\"Mercator_1SP\"],PARAMETER[\"central_meridian\",0],PARAMETER[\"scale_factor\",1],PARAMETER[\"false_easting\",0],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH],EXTENSION[\"PROJ4\",\"+proj=merc +a=6378137 +b=6378137 +lat_ts=0 +lon_0=0 +x_0=0 +y_0=0 +k=1 +units=m +nadgrids=@null +wktext +no_defs\"],AUTHORITY[\"EPSG\",\"3857\"]]'), metadata={'mosaic_method': 'FirstMethod', 'mosaic_assets_count': 5, 'mosaic_assets_used': 1, 'timings': [('search', 0.51), ('mosaicking', 3405.62)]}, nodata=None, scales=[1.0], offsets=[0.0], band_names=['B01_b1'], band_descriptions=['B01_'], dataset_statistics=None, cutline_mask=None, alpha_mask=None)\n</pre> In\u00a0[23]: Copied! <pre># Read Point values\nwith DynamicStacBackend(\n    \"https://earth-search.aws.element84.com/v0/search\",\n    query=query,\n    stac_api_options={\"max_items\": 5},\n    minzoom=8,  # we know this by analysing the sentinel 2 data\n    maxzoom=12,  # we know this by analysing the sentinel 2 data\n) as mosaic:\n    print(len(mosaic.assets_for_point(-1.0546875,  51.99)))\n    values = mosaic.point(-1.0546875,  51.99, assets=\"B01\")\n\n    for (f, v) in values:\n        print(f.split(\"/\")[-1], v.data)\n</pre> # Read Point values with DynamicStacBackend(     \"https://earth-search.aws.element84.com/v0/search\",     query=query,     stac_api_options={\"max_items\": 5},     minzoom=8,  # we know this by analysing the sentinel 2 data     maxzoom=12,  # we know this by analysing the sentinel 2 data ) as mosaic:     print(len(mosaic.assets_for_point(-1.0546875,  51.99)))     values = mosaic.point(-1.0546875,  51.99, assets=\"B01\")      for (f, v) in values:         print(f.split(\"/\")[-1], v.data) <pre>5\nS2A_30UXC_20251118_0_L2A [241]\nS2B_30UXC_20251101_0_L2A [5133]\nS2B_30UXC_20250922_1_L2A [318]\nS2A_30UXC_20250711_1_L2A [525]\nS2C_30UXC_20250619_0_L2A [362]\n</pre>"},{"location":"examples/Create_a_Dynamic_StacBackend/#create-a-dynamic-stac-backend","title":"Create a Dynamic STAC backend\u00b6","text":"<p>By default cogeo-mosaic backends were meant to handle writing and reading mosaicjson either from a file or from a database.</p> <p>While this is fine for most use cases, some users could want something more <code>dynamic</code>. In this Notebook we will show how to create a Dynamic mosaic backend based on STAC api.</p>"},{"location":"examples/Create_a_Dynamic_StacBackend/#requirements","title":"Requirements\u00b6","text":"<p>To be able to run this notebook you'll need the following requirements:</p> <ul> <li>cogeo-mosaic</li> </ul>"}]}